# [repr (transparent)] pub struct Internal ([u64 ; 1usize]) ; type REPR_BYTES = [u8 ; 8usize] ; type REPR_BITS = REPR_BYTES ; # [doc = r" This is the modulus m of the prime field"] const MODULUS : REPR_BITS = [1u8 , 0u8 , 72u8 , 255u8 , 19u8 , 152u8 , 126u8 , 18u8 ,] ; # [doc = r" This is the modulus m of the prime field in limb form"] const MODULUS_LIMBS : Internal = Internal ([1332669751402954753u64 ,]) ; # [doc = r" The number of bits needed to represent the modulus."] const MODULUS_BITS : u32 = 61u32 ; # [doc = r" The number of bits that must be shaved from the beginning of"] # [doc = r" the representation when randomly sampling."] const REPR_SHAVE_BITS : u32 = 3u32 ; # [doc = r" 2^{limbs*64} mod m"] const R : Internal = Internal ([1122037305471139827u64 ,]) ; # [doc = r" 2^{limbs*64*2} mod m"] const R2 : Internal = Internal ([1097646093484682845u64 ,]) ; # [doc = r" -(m^{-1} mod m) mod m"] const INV : u64 = 11618745889904394239u64 ; # [doc = r" Multiplicative generator of `MODULUS` - 1 order, also quadratic"] # [doc = r" nonresidue."] const GENERATOR : Internal = Internal ([1190912381283205024u64 ,]) ; # [doc = r" 2^s * t = MODULUS - 1 with t odd"] const S : u32 = 19u32 ; # [doc = r" 2^s root of unity computed by GENERATOR^t"] const ROOT_OF_UNITY : Internal = Internal ([238871501408271510u64 ,]) ; # [derive (Copy , Clone)] pub struct InternalRepr (pub [u8 ; 8usize]) ; impl :: ff :: derive :: subtle :: ConstantTimeEq for InternalRepr { fn ct_eq (& self , other : & InternalRepr) -> :: ff :: derive :: subtle :: Choice { self . 0 . iter () . zip (other . 0 . iter ()) . map (| (a , b) | a . ct_eq (b)) . fold (1 . into () , | acc , x | acc & x) } } impl :: core :: cmp :: PartialEq for InternalRepr { fn eq (& self , other : & InternalRepr) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for InternalRepr { } impl :: core :: default :: Default for InternalRepr { fn default () -> InternalRepr { InternalRepr ([0u8 ; 8usize]) } } impl :: core :: fmt :: Debug for InternalRepr { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "0x") ? ; for i in self . 0 . iter () . rev () { write ! (f , "{:02x}" , * i) ? ; } Ok (()) } } impl AsRef < [u8] > for InternalRepr { # [inline (always)] fn as_ref (& self) -> & [u8] { & self . 0 } } impl AsMut < [u8] > for InternalRepr { # [inline (always)] fn as_mut (& mut self) -> & mut [u8] { & mut self . 0 } } impl :: core :: marker :: Copy for Internal { } impl :: core :: clone :: Clone for Internal { fn clone (& self) -> Internal { * self } } impl :: core :: default :: Default for Internal { fn default () -> Internal { use :: ff :: Field ; Internal :: zero () } } impl :: ff :: derive :: subtle :: ConstantTimeEq for Internal { fn ct_eq (& self , other : & Internal) -> :: ff :: derive :: subtle :: Choice { use :: ff :: PrimeField ; self . to_repr () . ct_eq (& other . to_repr ()) } } impl :: core :: cmp :: PartialEq for Internal { fn eq (& self , other : & Internal) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for Internal { } impl :: core :: fmt :: Debug for Internal { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use :: ff :: PrimeField ; write ! (f , "{}({:?})" , stringify ! (Internal) , self . to_repr ()) } } # [doc = r" Elements are ordered lexicographically."] impl Ord for Internal { # [inline (always)] fn cmp (& self , other : & Internal) -> :: core :: cmp :: Ordering { let mut a = * self ; a . mont_reduce (self . 0 [0usize] , 0) ; let mut b = * other ; b . mont_reduce (other . 0 [0usize] , 0) ; a . cmp_native (& b) } } impl PartialOrd for Internal { # [inline (always)] fn partial_cmp (& self , other : & Internal) -> Option < :: core :: cmp :: Ordering > { Some (self . cmp (other)) } } impl From < u64 > for Internal { # [inline (always)] fn from (val : u64) -> Internal { let mut raw = [0u64 ; 1usize] ; raw [0] = val ; Internal (raw) * R2 } } impl From < Internal > for InternalRepr { fn from (e : Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl < 'a > From < & 'a Internal > for InternalRepr { fn from (e : & 'a Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl :: ff :: derive :: subtle :: ConditionallySelectable for Internal { fn conditional_select (a : & Internal , b : & Internal , choice : :: ff :: derive :: subtle :: Choice) -> Internal { let mut res = [0u64 ; 1usize] ; for i in 0 .. 1usize { res [i] = u64 :: conditional_select (& a . 0 [i] , & b . 0 [i] , choice) ; } Internal (res) } } impl :: core :: ops :: Neg for Internal { type Output = Internal ; # [inline] fn neg (self) -> Internal { use :: ff :: Field ; let mut ret = self ; if ! ret . is_zero_vartime () { let mut tmp = MODULUS_LIMBS ; tmp . sub_noborrow (& ret) ; ret = tmp ; } ret } } impl < 'r > :: core :: ops :: Add < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn add (self , other : & Internal) -> Internal { use :: core :: ops :: AddAssign ; let mut ret = self ; ret . add_assign (other) ; ret } } impl :: core :: ops :: Add for Internal { type Output = Internal ; # [inline] fn add (self , other : Internal) -> Self { self + & other } } impl < 'r > :: core :: ops :: AddAssign < & 'r Internal > for Internal { # [inline] fn add_assign (& mut self , other : & Internal) { self . add_nocarry (other) ; self . reduce () ; } } impl :: core :: ops :: AddAssign for Internal { # [inline] fn add_assign (& mut self , other : Internal) { self . add_assign (& other) ; } } impl < 'r > :: core :: ops :: Sub < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn sub (self , other : & Internal) -> Self { use :: core :: ops :: SubAssign ; let mut ret = self ; ret . sub_assign (other) ; ret } } impl :: core :: ops :: Sub for Internal { type Output = Internal ; # [inline] fn sub (self , other : Internal) -> Self { self - & other } } impl < 'r > :: core :: ops :: SubAssign < & 'r Internal > for Internal { # [inline] fn sub_assign (& mut self , other : & Internal) { if other . cmp_native (self) == :: core :: cmp :: Ordering :: Greater { self . add_nocarry (& MODULUS_LIMBS) ; } self . sub_noborrow (other) ; } } impl :: core :: ops :: SubAssign for Internal { # [inline] fn sub_assign (& mut self , other : Internal) { self . sub_assign (& other) ; } } impl < 'r > :: core :: ops :: Mul < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn mul (self , other : & Internal) -> Self { use :: core :: ops :: MulAssign ; let mut ret = self ; ret . mul_assign (other) ; ret } } impl :: core :: ops :: Mul for Internal { type Output = Internal ; # [inline] fn mul (self , other : Internal) -> Self { self * & other } } impl < 'r > :: core :: ops :: MulAssign < & 'r Internal > for Internal { # [inline] fn mul_assign (& mut self , other : & Internal) { let carry = 0 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [0usize] , carry) ; let r1 = carry ; self . mont_reduce (r0 , r1) ; } } impl :: core :: ops :: MulAssign for Internal { # [inline] fn mul_assign (& mut self , other : Internal) { self . mul_assign (& other) ; } } impl :: ff :: PrimeField for Internal { type Repr = InternalRepr ; fn from_repr (r : InternalRepr) -> :: ff :: derive :: subtle :: CtOption < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 1usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; let borrow = r . 0 . iter () . zip (MODULUS_LIMBS . 0 . iter ()) . fold (0 , | borrow , (a , b) | { :: ff :: derive :: sbb (* a , * b , borrow) . 1 }) ; let is_some = :: ff :: derive :: subtle :: Choice :: from ((borrow as u8) & 1) ; :: ff :: derive :: subtle :: CtOption :: new (r * & R2 , is_some) } fn from_repr_vartime (r : InternalRepr) -> Option < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 1usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; if r . is_valid () { Some (r * R2) } else { None } } fn to_repr (& self) -> InternalRepr { use :: ff :: derive :: byteorder :: ByteOrder ; let mut r = * self ; r . mont_reduce (self . 0 [0usize] , 0) ; let mut repr = [0u8 ; 8usize] ; :: ff :: derive :: byteorder :: LittleEndian :: write_u64_into (& r . 0 , & mut repr [..]) ; InternalRepr (repr) } # [inline (always)] fn is_odd (& self) -> :: ff :: derive :: subtle :: Choice { let mut r = * self ; r . mont_reduce (self . 0 [0usize] , 0) ; :: ff :: derive :: subtle :: Choice :: from ((r . 0 [0] & 1) as u8) } const NUM_BITS : u32 = MODULUS_BITS ; const CAPACITY : u32 = Self :: NUM_BITS - 1 ; fn multiplicative_generator () -> Self { GENERATOR } const MULTIPLICATIVE_GENERATOR : Self = GENERATOR ; const S : u32 = S ; fn root_of_unity () -> Self { ROOT_OF_UNITY } } impl :: ff :: Field for Internal { # [doc = r" Computes a uniformly random element using rejection sampling."] fn random (mut rng : impl :: ff :: derive :: rand_core :: RngCore) -> Self { loop { let mut tmp = { let mut repr = [0u64 ; 1usize] ; for i in 0 .. 1usize { repr [i] = rng . next_u64 () ; } Internal (repr) } ; tmp . 0 . as_mut () [0usize] &= 0xffffffffffffffffu64 . checked_shr (REPR_SHAVE_BITS) . unwrap_or (0) ; if tmp . is_valid () { return tmp } } } # [inline] fn zero () -> Self { Internal ([0 ; 1usize]) } const ZERO : Self = Internal ([0 ; 1usize]) ; # [inline] fn one () -> Self { R } const ONE : Self = R ; # [inline] fn is_zero (& self) -> :: ff :: derive :: subtle :: Choice { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (& Self :: zero ()) } # [inline] fn is_zero_vartime (& self) -> bool { self . 0 . iter () . all (| & e | e == 0) } # [inline] fn double (& self) -> Self { let mut ret = * self ; let mut last = 0 ; for i in & mut ret . 0 { let tmp = * i >> 63 ; * i <<= 1 ; * i |= last ; last = tmp ; } ret . reduce () ; ret } fn invert (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let inv = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 . square () ; let t3 = t2 * t0 ; let t4 = t3 * t1 ; let t5 = t4 . square () ; let t6 = t5 * t4 ; let t7 = t6 * t3 ; let t8 = t7 . square () ; let t9 = t8 * t7 ; let t10 = t9 * t8 ; let t11 = t10 . square () ; let t12 = t11 . square () ; let t13 = t12 * t9 ; let t14 = t13 * t4 ; let t15 = t14 * t7 ; let t16 = t15 . square () ; let t17 = t16 . square () ; let t18 = t17 . square () ; let t19 = t18 * t14 ; let t20 = t19 . square () ; let t21 = t20 * t19 ; let t22 = t21 * t15 ; let t23 = t22 . square () ; let t24 = t23 * t22 ; let t25 = t24 * t19 ; let t26 = t25 * t22 ; let t27 = t26 . square () ; let t28 = t27 * t26 ; let t29 = t28 . square () ; let t30 = t28 . square () ; let t31 = t29 * t25 ; let t32 = t31 . square () ; let t33 = t32 * t31 ; let t34 = t33 * t26 ; let t35 = t34 . square () ; let t36 = t35 . square () ; let t37 = t36 . square () ; let t38 = t37 * t31 ; let t39 = t38 * t34 ; let t40 = t39 . square () ; let t41 = t40 . square () ; let t42 = t41 * t39 ; let t43 = t42 . square () ; let t44 = t42 . square () ; let t45 = t43 * t38 ; let t46 = t45 * t39 ; let t47 = t46 . square () ; let t48 = t47 . square () ; let t49 = t48 * t46 ; let t50 = t49 * t45 ; let t51 = t50 * t46 ; let t52 = t51 . square () ; let t53 = t52 . square () ; let t54 = t53 . square () ; let t55 = t54 . square () ; let t56 = t55 . square () ; let t57 = t56 . square () ; let t58 = t57 . square () ; let t59 = t58 . square () ; let t60 = t59 . square () ; let t61 = t60 . square () ; let t62 = t61 . square () ; let t63 = t62 . square () ; let t64 = t63 . square () ; let t65 = t64 . square () ; let t66 = t65 . square () ; let t67 = t66 . square () ; let t68 = t67 . square () ; let t69 = t68 . square () ; let t70 = t69 . square () ; let t71 = t70 . square () ; let t72 = t71 . square () ; let t73 = t72 . square () ; let t74 = t73 . square () ; let t75 = t74 . square () ; let t76 = t75 . square () ; let t77 = t76 . square () ; let t78 = t77 . square () ; let t79 = t78 . square () ; let t80 = t79 . square () ; let t81 = t80 . square () ; let t82 = t81 * t50 ; t82 } ; :: ff :: derive :: subtle :: CtOption :: new (inv , ! self . ct_eq (& Internal :: zero ())) } # [inline] fn square (& self) -> Self { let r1 = 0 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [0usize] , 0) ; let (r1 , carry) = :: ff :: derive :: adc (r1 , 0 , carry) ; let mut ret = * self ; ret . mont_reduce (r0 , r1) ; ret } fn sqrt (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: { ConditionallySelectable , ConstantTimeEq } ; let w = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 . square () ; let t3 = t2 . square () ; let t4 = t3 * t2 ; let t5 = t4 . square () ; let t6 = t4 . square () ; let t7 = t4 . square () ; let t8 = t5 . square () ; let t9 = t8 * t5 ; let t10 = t9 . square () ; let t11 = t9 . square () ; let t12 = t10 * t2 ; let t13 = t12 . square () ; let t14 = t13 * t12 ; let t15 = t14 . square () ; let t16 = t14 . square () ; let t17 = t15 * t5 ; let t18 = t17 . square () ; let t19 = t18 . square () ; let t20 = t19 . square () ; let t21 = t20 . square () ; let t22 = t21 * t17 ; let t23 = t22 * t12 ; let t24 = t23 * t17 ; let t25 = t24 . square () ; let t26 = t25 * t24 ; let t27 = t26 * t23 ; let t28 = t27 * t24 ; let t29 = t28 . square () ; let t30 = t29 * t28 ; let t31 = t30 . square () ; let t32 = t31 * t28 ; let t33 = t32 . square () ; let t34 = t32 . square () ; let t35 = t33 * t27 ; let t36 = t35 . square () ; let t37 = t36 . square () ; let t38 = t37 . square () ; let t39 = t38 . square () ; let t40 = t39 . square () ; let t41 = t40 . square () ; let t42 = t41 . square () ; let t43 = t42 . square () ; let t44 = t43 . square () ; let t45 = t44 . square () ; let t46 = t45 . square () ; let t47 = t46 . square () ; let t48 = t47 . square () ; let t49 = t48 . square () ; let t50 = t49 . square () ; let t51 = t50 . square () ; let t52 = t51 . square () ; let t53 = t52 . square () ; let t54 = t53 . square () ; let t55 = t54 . square () ; let t56 = t55 * t28 ; t56 } ; let mut v = S ; let mut x = * self * & w ; let mut b = x * & w ; let mut z = ROOT_OF_UNITY ; for max_v in (1 ..= S) . rev () { let mut k = 1 ; let mut tmp = b . square () ; let mut j_less_than_v : :: ff :: derive :: subtle :: Choice = 1 . into () ; for j in 2 .. max_v { let tmp_is_one = tmp . ct_eq (& Internal :: one ()) ; let squared = Internal :: conditional_select (& tmp , & z , tmp_is_one) . square () ; tmp = Internal :: conditional_select (& squared , & tmp , tmp_is_one) ; let new_z = Internal :: conditional_select (& z , & squared , tmp_is_one) ; j_less_than_v &= ! j . ct_eq (& v) ; k = u32 :: conditional_select (& j , & k , tmp_is_one) ; z = Internal :: conditional_select (& z , & new_z , j_less_than_v) ; } let result = x * & z ; x = Internal :: conditional_select (& result , & x , b . ct_eq (& Internal :: one ())) ; z = z . square () ; b *= & z ; v = k ; } :: ff :: derive :: subtle :: CtOption :: new (x , (x * & x) . ct_eq (self) ,) } } impl Internal { # [doc = r" Compares two elements in native representation. This is only used"] # [doc = r" internally."] # [inline (always)] fn cmp_native (& self , other : & Internal) -> :: core :: cmp :: Ordering { for (a , b) in self . 0 . iter () . rev () . zip (other . 0 . iter () . rev ()) { if a < b { return :: core :: cmp :: Ordering :: Less } else if a > b { return :: core :: cmp :: Ordering :: Greater } } :: core :: cmp :: Ordering :: Equal } # [doc = r" Determines if the element is really in the field. This is only used"] # [doc = r" internally."] # [inline (always)] fn is_valid (& self) -> bool { self . cmp_native (& MODULUS_LIMBS) == :: core :: cmp :: Ordering :: Less } # [inline (always)] fn add_nocarry (& mut self , other : & Internal) { let mut carry = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_carry) = :: ff :: derive :: adc (* a , * b , carry) ; * a = new_a ; carry = new_carry ; } } # [inline (always)] fn sub_noborrow (& mut self , other : & Internal) { let mut borrow = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_borrow) = :: ff :: derive :: sbb (* a , * b , borrow) ; * a = new_a ; borrow = new_borrow ; } } # [doc = r" Subtracts the modulus from this element if this element is not in the"] # [doc = r" field. Only used interally."] # [inline (always)] fn reduce (& mut self) { if ! self . is_valid () { self . sub_noborrow (& MODULUS_LIMBS) ; } } # [allow (clippy :: too_many_arguments)] # [inline (always)] fn mont_reduce (& mut self , r0 : u64 , mut r1 : u64) { let k = r0 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r0 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r1 , carry2) = :: ff :: derive :: adc (r1 , 0 , carry) ; self . 0 [0usize] = r1 ; self . reduce () ; } }#[cfg(test)] pub(super) const MODULUS_STRING: &str = "1332669751402954753";pub(super) const MODULUS_BYTES: &[u8] = &[1, 0, 72, 255, 19, 152, 126, 18];#[cfg(test)] pub(super) const GENERATOR_STRING: &str = "7";