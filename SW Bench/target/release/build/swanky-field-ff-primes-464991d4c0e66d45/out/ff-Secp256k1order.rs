# [repr (transparent)] pub struct Internal ([u64 ; 5usize]) ; type REPR_BYTES = [u8 ; 40usize] ; type REPR_BITS = REPR_BYTES ; # [doc = r" This is the modulus m of the prime field"] const MODULUS : REPR_BITS = [65u8 , 65u8 , 54u8 , 208u8 , 140u8 , 94u8 , 210u8 , 191u8 , 59u8 , 160u8 , 72u8 , 175u8 , 230u8 , 220u8 , 174u8 , 186u8 , 254u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 ,] ; # [doc = r" This is the modulus m of the prime field in limb form"] const MODULUS_LIMBS : Internal = Internal ([13822214165235122497u64 , 13451932020343611451u64 , 18446744073709551614u64 , 18446744073709551615u64 , 0u64 ,]) ; # [doc = r" The number of bits needed to represent the modulus."] const MODULUS_BITS : u32 = 256u32 ; # [doc = r" The number of bits that must be shaved from the beginning of"] # [doc = r" the representation when randomly sampling."] const REPR_SHAVE_BITS : u32 = 64u32 ; # [doc = r" 2^{limbs*64} mod m"] const R : Internal = Internal ([0u64 , 4624529908474429119u64 , 4994812053365940164u64 , 1u64 , 0u64 ,]) ; # [doc = r" 2^{limbs*64*2} mod m"] const R2 : Internal = Internal ([2161815027462274937u64 , 647662477280039658u64 , 2865435121925625427u64 , 4330881270917637700u64 , 0u64 ,]) ; # [doc = r" -(m^{-1} mod m) mod m"] const INV : u64 = 5408259542528602431u64 ; # [doc = r" Multiplicative generator of `MODULUS` - 1 order, also quadratic"] # [doc = r" nonresidue."] const GENERATOR : Internal = Internal ([0u64 , 13924965285611452217u64 , 16516940299852029533u64 , 8u64 , 0u64 ,]) ; # [doc = r" 2^s * t = MODULUS - 1 with t odd"] const S : u32 = 6u32 ; # [doc = r" 2^s root of unity computed by GENERATOR^t"] const ROOT_OF_UNITY : Internal = Internal ([77347410520187210u64 , 10530081889165329664u64 , 9097834448175194642u64 , 6167691817532924180u64 , 0u64 ,]) ; # [derive (Copy , Clone)] pub struct InternalRepr (pub [u8 ; 40usize]) ; impl :: ff :: derive :: subtle :: ConstantTimeEq for InternalRepr { fn ct_eq (& self , other : & InternalRepr) -> :: ff :: derive :: subtle :: Choice { self . 0 . iter () . zip (other . 0 . iter ()) . map (| (a , b) | a . ct_eq (b)) . fold (1 . into () , | acc , x | acc & x) } } impl :: core :: cmp :: PartialEq for InternalRepr { fn eq (& self , other : & InternalRepr) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for InternalRepr { } impl :: core :: default :: Default for InternalRepr { fn default () -> InternalRepr { InternalRepr ([0u8 ; 40usize]) } } impl :: core :: fmt :: Debug for InternalRepr { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "0x") ? ; for i in self . 0 . iter () . rev () { write ! (f , "{:02x}" , * i) ? ; } Ok (()) } } impl AsRef < [u8] > for InternalRepr { # [inline (always)] fn as_ref (& self) -> & [u8] { & self . 0 } } impl AsMut < [u8] > for InternalRepr { # [inline (always)] fn as_mut (& mut self) -> & mut [u8] { & mut self . 0 } } impl :: core :: marker :: Copy for Internal { } impl :: core :: clone :: Clone for Internal { fn clone (& self) -> Internal { * self } } impl :: core :: default :: Default for Internal { fn default () -> Internal { use :: ff :: Field ; Internal :: zero () } } impl :: ff :: derive :: subtle :: ConstantTimeEq for Internal { fn ct_eq (& self , other : & Internal) -> :: ff :: derive :: subtle :: Choice { use :: ff :: PrimeField ; self . to_repr () . ct_eq (& other . to_repr ()) } } impl :: core :: cmp :: PartialEq for Internal { fn eq (& self , other : & Internal) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for Internal { } impl :: core :: fmt :: Debug for Internal { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use :: ff :: PrimeField ; write ! (f , "{}({:?})" , stringify ! (Internal) , self . to_repr ()) } } # [doc = r" Elements are ordered lexicographically."] impl Ord for Internal { # [inline (always)] fn cmp (& self , other : & Internal) -> :: core :: cmp :: Ordering { let mut a = * self ; a . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , 0 , 0 , 0 , 0 , 0) ; let mut b = * other ; b . mont_reduce (other . 0 [0usize] , other . 0 [1usize] , other . 0 [2usize] , other . 0 [3usize] , other . 0 [4usize] , 0 , 0 , 0 , 0 , 0) ; a . cmp_native (& b) } } impl PartialOrd for Internal { # [inline (always)] fn partial_cmp (& self , other : & Internal) -> Option < :: core :: cmp :: Ordering > { Some (self . cmp (other)) } } impl From < u64 > for Internal { # [inline (always)] fn from (val : u64) -> Internal { let mut raw = [0u64 ; 5usize] ; raw [0] = val ; Internal (raw) * R2 } } impl From < Internal > for InternalRepr { fn from (e : Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl < 'a > From < & 'a Internal > for InternalRepr { fn from (e : & 'a Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl :: ff :: derive :: subtle :: ConditionallySelectable for Internal { fn conditional_select (a : & Internal , b : & Internal , choice : :: ff :: derive :: subtle :: Choice) -> Internal { let mut res = [0u64 ; 5usize] ; for i in 0 .. 5usize { res [i] = u64 :: conditional_select (& a . 0 [i] , & b . 0 [i] , choice) ; } Internal (res) } } impl :: core :: ops :: Neg for Internal { type Output = Internal ; # [inline] fn neg (self) -> Internal { use :: ff :: Field ; let mut ret = self ; if ! ret . is_zero_vartime () { let mut tmp = MODULUS_LIMBS ; tmp . sub_noborrow (& ret) ; ret = tmp ; } ret } } impl < 'r > :: core :: ops :: Add < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn add (self , other : & Internal) -> Internal { use :: core :: ops :: AddAssign ; let mut ret = self ; ret . add_assign (other) ; ret } } impl :: core :: ops :: Add for Internal { type Output = Internal ; # [inline] fn add (self , other : Internal) -> Self { self + & other } } impl < 'r > :: core :: ops :: AddAssign < & 'r Internal > for Internal { # [inline] fn add_assign (& mut self , other : & Internal) { self . add_nocarry (other) ; self . reduce () ; } } impl :: core :: ops :: AddAssign for Internal { # [inline] fn add_assign (& mut self , other : Internal) { self . add_assign (& other) ; } } impl < 'r > :: core :: ops :: Sub < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn sub (self , other : & Internal) -> Self { use :: core :: ops :: SubAssign ; let mut ret = self ; ret . sub_assign (other) ; ret } } impl :: core :: ops :: Sub for Internal { type Output = Internal ; # [inline] fn sub (self , other : Internal) -> Self { self - & other } } impl < 'r > :: core :: ops :: SubAssign < & 'r Internal > for Internal { # [inline] fn sub_assign (& mut self , other : & Internal) { if other . cmp_native (self) == :: core :: cmp :: Ordering :: Greater { self . add_nocarry (& MODULUS_LIMBS) ; } self . sub_noborrow (other) ; } } impl :: core :: ops :: SubAssign for Internal { # [inline] fn sub_assign (& mut self , other : Internal) { self . sub_assign (& other) ; } } impl < 'r > :: core :: ops :: Mul < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn mul (self , other : & Internal) -> Self { use :: core :: ops :: MulAssign ; let mut ret = self ; ret . mul_assign (other) ; ret } } impl :: core :: ops :: Mul for Internal { type Output = Internal ; # [inline] fn mul (self , other : Internal) -> Self { self * & other } } impl < 'r > :: core :: ops :: MulAssign < & 'r Internal > for Internal { # [inline] fn mul_assign (& mut self , other : & Internal) { let carry = 0 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [0usize] , carry) ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [4usize] , carry) ; let r5 = carry ; let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (r1 , self . 0 [1usize] , other . 0 [0usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , other . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , other . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , other . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [1usize] , other . 0 [4usize] , carry) ; let r6 = carry ; let carry = 0 ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [2usize] , other . 0 [0usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [2usize] , other . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , other . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , other . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [2usize] , other . 0 [4usize] , carry) ; let r7 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [3usize] , other . 0 [0usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [3usize] , other . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [3usize] , other . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , other . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [3usize] , other . 0 [4usize] , carry) ; let r8 = carry ; let carry = 0 ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [4usize] , other . 0 [0usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [4usize] , other . 0 [1usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [4usize] , other . 0 [2usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [4usize] , other . 0 [3usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [4usize] , other . 0 [4usize] , carry) ; let r9 = carry ; self . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9) ; } } impl :: core :: ops :: MulAssign for Internal { # [inline] fn mul_assign (& mut self , other : Internal) { self . mul_assign (& other) ; } } impl :: ff :: PrimeField for Internal { type Repr = InternalRepr ; fn from_repr (r : InternalRepr) -> :: ff :: derive :: subtle :: CtOption < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 5usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; let borrow = r . 0 . iter () . zip (MODULUS_LIMBS . 0 . iter ()) . fold (0 , | borrow , (a , b) | { :: ff :: derive :: sbb (* a , * b , borrow) . 1 }) ; let is_some = :: ff :: derive :: subtle :: Choice :: from ((borrow as u8) & 1) ; :: ff :: derive :: subtle :: CtOption :: new (r * & R2 , is_some) } fn from_repr_vartime (r : InternalRepr) -> Option < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 5usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; if r . is_valid () { Some (r * R2) } else { None } } fn to_repr (& self) -> InternalRepr { use :: ff :: derive :: byteorder :: ByteOrder ; let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , 0 , 0 , 0 , 0 , 0) ; let mut repr = [0u8 ; 40usize] ; :: ff :: derive :: byteorder :: LittleEndian :: write_u64_into (& r . 0 , & mut repr [..]) ; InternalRepr (repr) } # [inline (always)] fn is_odd (& self) -> :: ff :: derive :: subtle :: Choice { let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , 0 , 0 , 0 , 0 , 0) ; :: ff :: derive :: subtle :: Choice :: from ((r . 0 [0] & 1) as u8) } const NUM_BITS : u32 = MODULUS_BITS ; const CAPACITY : u32 = Self :: NUM_BITS - 1 ; fn multiplicative_generator () -> Self { GENERATOR } const MULTIPLICATIVE_GENERATOR : Self = GENERATOR ; const S : u32 = S ; fn root_of_unity () -> Self { ROOT_OF_UNITY } } impl :: ff :: Field for Internal { # [doc = r" Computes a uniformly random element using rejection sampling."] fn random (mut rng : impl :: ff :: derive :: rand_core :: RngCore) -> Self { loop { let mut tmp = { let mut repr = [0u64 ; 5usize] ; for i in 0 .. 5usize { repr [i] = rng . next_u64 () ; } Internal (repr) } ; tmp . 0 . as_mut () [4usize] &= 0xffffffffffffffffu64 . checked_shr (REPR_SHAVE_BITS) . unwrap_or (0) ; if tmp . is_valid () { return tmp } } } # [inline] fn zero () -> Self { Internal ([0 ; 5usize]) } const ZERO : Self = Internal ([0 ; 5usize]) ; # [inline] fn one () -> Self { R } const ONE : Self = R ; # [inline] fn is_zero (& self) -> :: ff :: derive :: subtle :: Choice { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (& Self :: zero ()) } # [inline] fn is_zero_vartime (& self) -> bool { self . 0 . iter () . all (| & e | e == 0) } # [inline] fn double (& self) -> Self { let mut ret = * self ; let mut last = 0 ; for i in & mut ret . 0 { let tmp = * i >> 63 ; * i <<= 1 ; * i |= last ; last = tmp ; } ret . reduce () ; ret } fn invert (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let inv = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 * t0 ; let t3 = t2 . square () ; let t4 = t3 * t2 ; let t5 = t4 . square () ; let t6 = t4 . square () ; let t7 = t5 * t0 ; let t8 = t7 * t2 ; let t9 = t8 . square () ; let t10 = t9 * t8 ; let t11 = t10 * t7 ; let t12 = t11 . square () ; let t13 = t12 * t8 ; let t14 = t13 * t11 ; let t15 = t14 . square () ; let t16 = t15 * t14 ; let t17 = t16 * t15 ; let t18 = t17 . square () ; let t19 = t18 . square () ; let t20 = t19 * t16 ; let t21 = t20 * t13 ; let t22 = t21 * t14 ; let t23 = t22 * t21 ; let t24 = t23 . square () ; let t25 = t24 . square () ; let t26 = t25 * t23 ; let t27 = t26 * t22 ; let t28 = t27 . square () ; let t29 = t28 . square () ; let t30 = t29 . square () ; let t31 = t30 * t23 ; let t32 = t31 * t27 ; let t33 = t32 . square () ; let t34 = t33 * t31 ; let t35 = t34 * t32 ; let t36 = t35 . square () ; let t37 = t36 * t34 ; let t38 = t37 * t35 ; let t39 = t38 * t37 ; let t40 = t39 . square () ; let t41 = t40 . square () ; let t42 = t41 . square () ; let t43 = t42 . square () ; let t44 = t43 * t39 ; let t45 = t44 * t38 ; let t46 = t45 * t39 ; let t47 = t46 . square () ; let t48 = t47 * t46 ; let t49 = t48 . square () ; let t50 = t48 . square () ; let t51 = t49 * t45 ; let t52 = t51 * t46 ; let t53 = t52 * t51 ; let t54 = t53 * t52 ; let t55 = t54 . square () ; let t56 = t55 * t54 ; let t57 = t56 . square () ; let t58 = t56 . square () ; let t59 = t57 * t53 ; let t60 = t59 * t54 ; let t61 = t60 . square () ; let t62 = t61 * t60 ; let t63 = t62 . square () ; let t64 = t62 . square () ; let t65 = t63 * t59 ; let t66 = t65 * t60 ; let t67 = t66 . square () ; let t68 = t67 . square () ; let t69 = t68 * t66 ; let t70 = t69 * t65 ; let t71 = t70 . square () ; let t72 = t71 * t70 ; let t73 = t72 * t66 ; let t74 = t73 . square () ; let t75 = t74 . square () ; let t76 = t75 . square () ; let t77 = t76 * t70 ; let t78 = t77 . square () ; let t79 = t78 * t73 ; let t80 = t79 . square () ; let t81 = t80 * t79 ; let t82 = t81 . square () ; let t83 = t82 * t80 ; let t84 = t83 . square () ; let t85 = t84 . square () ; let t86 = t85 * t81 ; let t87 = t86 * t77 ; let t88 = t87 . square () ; let t89 = t88 . square () ; let t90 = t89 . square () ; let t91 = t90 * t87 ; let t92 = t91 * t79 ; let t93 = t92 * t87 ; let t94 = t93 . square () ; let t95 = t94 * t92 ; let t96 = t95 . square () ; let t97 = t96 . square () ; let t98 = t97 * t95 ; let t99 = t98 . square () ; let t100 = t99 * t98 ; let t101 = t100 . square () ; let t102 = t100 . square () ; let t103 = t101 * t97 ; let t104 = t103 . square () ; let t105 = t104 . square () ; let t106 = t105 . square () ; let t107 = t106 . square () ; let t108 = t107 * t98 ; let t109 = t108 * t93 ; let t110 = t109 * t95 ; let t111 = t110 . square () ; let t112 = t111 . square () ; let t113 = t112 . square () ; let t114 = t113 * t112 ; let t115 = t113 * t112 ; let t116 = t114 . square () ; let t117 = t116 . square () ; let t118 = t117 . square () ; let t119 = t118 * t112 ; let t120 = t119 * t109 ; let t121 = t120 * t110 ; let t122 = t121 . square () ; let t123 = t122 * t120 ; let t124 = t123 * t121 ; let t125 = t124 . square () ; let t126 = t125 * t123 ; let t127 = t126 * t124 ; let t128 = t127 * t126 ; let t129 = t128 . square () ; let t130 = t129 . square () ; let t131 = t130 * t128 ; let t132 = t131 * t127 ; let t133 = t132 * t128 ; let t134 = t133 * t132 ; let t135 = t134 * t133 ; let t136 = t135 . square () ; let t137 = t136 * t135 ; let t138 = t137 . square () ; let t139 = t138 * t135 ; let t140 = t139 * t134 ; let t141 = t140 * t135 ; let t142 = t141 . square () ; let t143 = t142 . square () ; let t144 = t143 . square () ; let t145 = t144 . square () ; let t146 = t145 * t141 ; let t147 = t146 * t140 ; let t148 = t147 . square () ; let t149 = t148 * t147 ; let t150 = t149 * t141 ; let t151 = t150 . square () ; let t152 = t151 * t150 ; let t153 = t152 . square () ; let t154 = t153 * t152 ; let t155 = t154 . square () ; let t156 = t155 * t152 ; let t157 = t156 * t150 ; let t158 = t157 . square () ; let t159 = t158 . square () ; let t160 = t159 . square () ; let t161 = t160 * t152 ; let t162 = t161 * t147 ; let t163 = t162 * t150 ; let t164 = t163 . square () ; let t165 = t164 * t163 ; let t166 = t165 . square () ; let t167 = t165 . square () ; let t168 = t166 * t162 ; let t169 = t168 . square () ; let t170 = t169 . square () ; let t171 = t170 . square () ; let t172 = t171 * t168 ; let t173 = t172 * t163 ; let t174 = t173 . square () ; let t175 = t174 * t173 ; let t176 = t175 . square () ; let t177 = t175 . square () ; let t178 = t176 . square () ; let t179 = t178 . square () ; let t180 = t178 . square () ; let t181 = t179 * t168 ; let t182 = t181 * t173 ; let t183 = t182 . square () ; let t184 = t183 . square () ; let t185 = t184 * t181 ; let t186 = t185 * t182 ; let t187 = t186 . square () ; let t188 = t187 . square () ; let t189 = t188 . square () ; let t190 = t189 * t185 ; let t191 = t190 * t186 ; let t192 = t191 . square () ; let t193 = t192 * t191 ; let t194 = t193 . square () ; let t195 = t194 * t191 ; let t196 = t195 . square () ; let t197 = t196 * t191 ; let t198 = t197 * t190 ; let t199 = t198 . square () ; let t200 = t199 * t198 ; let t201 = t200 * t191 ; let t202 = t201 * t198 ; let t203 = t202 . square () ; let t204 = t203 * t201 ; let t205 = t204 * t202 ; let t206 = t205 * t204 ; let t207 = t206 * t205 ; let t208 = t207 . square () ; let t209 = t208 * t206 ; let t210 = t209 * t207 ; let t211 = t210 . square () ; let t212 = t211 . square () ; let t213 = t212 . square () ; let t214 = t213 * t209 ; let t215 = t214 . square () ; let t216 = t215 . square () ; let t217 = t216 . square () ; let t218 = t217 . square () ; let t219 = t218 . square () ; let t220 = t219 . square () ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 . square () ; let t228 = t227 . square () ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 . square () ; let t234 = t233 . square () ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 . square () ; let t240 = t239 . square () ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 . square () ; let t245 = t244 . square () ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 . square () ; let t249 = t248 . square () ; let t250 = t249 . square () ; let t251 = t250 . square () ; let t252 = t251 . square () ; let t253 = t252 . square () ; let t254 = t253 . square () ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 . square () ; let t258 = t257 . square () ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 . square () ; let t262 = t261 . square () ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 . square () ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 . square () ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 . square () ; let t272 = t271 . square () ; let t273 = t272 . square () ; let t274 = t273 . square () ; let t275 = t274 . square () ; let t276 = t275 . square () ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 . square () ; let t281 = t280 . square () ; let t282 = t281 . square () ; let t283 = t282 . square () ; let t284 = t283 . square () ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 . square () ; let t289 = t288 . square () ; let t290 = t289 . square () ; let t291 = t290 . square () ; let t292 = t291 . square () ; let t293 = t292 . square () ; let t294 = t293 . square () ; let t295 = t294 . square () ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 . square () ; let t299 = t298 . square () ; let t300 = t299 . square () ; let t301 = t300 . square () ; let t302 = t301 . square () ; let t303 = t302 . square () ; let t304 = t303 . square () ; let t305 = t304 . square () ; let t306 = t305 . square () ; let t307 = t306 . square () ; let t308 = t307 . square () ; let t309 = t308 . square () ; let t310 = t309 . square () ; let t311 = t310 . square () ; let t312 = t311 . square () ; let t313 = t312 . square () ; let t314 = t313 . square () ; let t315 = t314 . square () ; let t316 = t315 . square () ; let t317 = t316 . square () ; let t318 = t317 . square () ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 . square () ; let t322 = t321 . square () ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 . square () ; let t339 = t338 . square () ; let t340 = t339 . square () ; let t341 = t340 . square () ; let t342 = t341 * t210 ; t342 } ; :: ff :: derive :: subtle :: CtOption :: new (inv , ! self . ct_eq (& Internal :: zero ())) } # [inline] fn square (& self) -> Self { let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [4usize] , carry) ; let r5 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , self . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , self . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [1usize] , self . 0 [4usize] , carry) ; let r6 = carry ; let carry = 0 ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , self . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [2usize] , self . 0 [4usize] , carry) ; let r7 = carry ; let carry = 0 ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [3usize] , self . 0 [4usize] , carry) ; let r8 = carry ; let r9 = r8 >> 63 ; let r8 = (r8 << 1) | (r7 >> 63) ; let r7 = (r7 << 1) | (r6 >> 63) ; let r6 = (r6 << 1) | (r5 >> 63) ; let r5 = (r5 << 1) | (r4 >> 63) ; let r4 = (r4 << 1) | (r3 >> 63) ; let r3 = (r3 << 1) | (r2 >> 63) ; let r2 = (r2 << 1) | (r1 >> 63) ; let r1 = r1 << 1 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [0usize] , 0) ; let (r1 , carry) = :: ff :: derive :: adc (r1 , 0 , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , self . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: adc (r3 , 0 , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , self . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: adc (r5 , 0 , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , self . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: adc (r7 , 0 , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [4usize] , self . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: adc (r9 , 0 , carry) ; let mut ret = * self ; ret . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9) ; ret } fn sqrt (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: { ConditionallySelectable , ConstantTimeEq } ; let w = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 * t0 ; let t3 = t1 . square () ; let t4 = t3 . square () ; let t5 = t4 * t2 ; let t6 = t5 * t3 ; let t7 = t6 . square () ; let t8 = t7 * t6 ; let t9 = t8 . square () ; let t10 = t9 * t6 ; let t11 = t10 * t5 ; let t12 = t11 * t6 ; let t13 = t12 . square () ; let t14 = t13 * t11 ; let t15 = t14 . square () ; let t16 = t15 * t12 ; let t17 = t16 . square () ; let t18 = t17 * t16 ; let t19 = t18 . square () ; let t20 = t18 . square () ; let t21 = t19 . square () ; let t22 = t21 * t16 ; let t23 = t22 * t14 ; let t24 = t23 * t16 ; let t25 = t24 . square () ; let t26 = t25 * t23 ; let t27 = t26 * t24 ; let t28 = t27 . square () ; let t29 = t28 * t27 ; let t30 = t29 . square () ; let t31 = t30 * t28 ; let t32 = t31 . square () ; let t33 = t32 . square () ; let t34 = t33 * t29 ; let t35 = t34 * t26 ; let t36 = t35 * t27 ; let t37 = t36 . square () ; let t38 = t37 . square () ; let t39 = t38 * t36 ; let t40 = t39 . square () ; let t41 = t40 . square () ; let t42 = t40 . square () ; let t43 = t41 * t35 ; let t44 = t43 * t36 ; let t45 = t44 . square () ; let t46 = t45 * t43 ; let t47 = t46 * t44 ; let t48 = t47 . square () ; let t49 = t48 * t46 ; let t50 = t49 . square () ; let t51 = t50 * t49 ; let t52 = t51 . square () ; let t53 = t52 * t50 ; let t54 = t53 . square () ; let t55 = t54 . square () ; let t56 = t55 * t51 ; let t57 = t56 * t47 ; let t58 = t57 . square () ; let t59 = t58 . square () ; let t60 = t59 * t57 ; let t61 = t60 * t49 ; let t62 = t61 . square () ; let t63 = t62 . square () ; let t64 = t63 . square () ; let t65 = t64 * t61 ; let t66 = t65 * t57 ; let t67 = t66 . square () ; let t68 = t67 . square () ; let t69 = t68 * t67 ; let t70 = t69 . square () ; let t71 = t70 * t67 ; let t72 = t71 * t66 ; let t73 = t72 . square () ; let t74 = t73 . square () ; let t75 = t74 * t67 ; let t76 = t75 * t61 ; let t77 = t76 * t66 ; let t78 = t77 . square () ; let t79 = t78 . square () ; let t80 = t79 * t77 ; let t81 = t80 * t76 ; let t82 = t81 . square () ; let t83 = t82 * t77 ; let t84 = t83 . square () ; let t85 = t84 . square () ; let t86 = t84 . square () ; let t87 = t85 . square () ; let t88 = t87 . square () ; let t89 = t88 * t84 ; let t90 = t89 * t81 ; let t91 = t90 . square () ; let t92 = t91 * t83 ; let t93 = t92 . square () ; let t94 = t93 * t92 ; let t95 = t94 . square () ; let t96 = t95 * t92 ; let t97 = t96 . square () ; let t98 = t96 . square () ; let t99 = t97 . square () ; let t100 = t99 . square () ; let t101 = t100 . square () ; let t102 = t100 . square () ; let t103 = t101 * t90 ; let t104 = t103 . square () ; let t105 = t104 . square () ; let t106 = t105 . square () ; let t107 = t106 * t103 ; let t108 = t107 * t92 ; let t109 = t108 . square () ; let t110 = t109 * t103 ; let t111 = t110 . square () ; let t112 = t111 . square () ; let t113 = t112 . square () ; let t114 = t113 * t110 ; let t115 = t114 * t108 ; let t116 = t115 * t110 ; let t117 = t116 . square () ; let t118 = t117 . square () ; let t119 = t118 * t116 ; let t120 = t119 * t115 ; let t121 = t120 . square () ; let t122 = t121 * t116 ; let t123 = t122 * t120 ; let t124 = t123 . square () ; let t125 = t124 * t123 ; let t126 = t125 . square () ; let t127 = t125 . square () ; let t128 = t126 . square () ; let t129 = t126 . square () ; let t130 = t128 * t122 ; let t131 = t130 * t123 ; let t132 = t131 . square () ; let t133 = t132 . square () ; let t134 = t133 . square () ; let t135 = t134 * t131 ; let t136 = t135 . square () ; let t137 = t136 . square () ; let t138 = t137 . square () ; let t139 = t138 * t132 ; let t140 = t139 * t130 ; let t141 = t140 * t131 ; let t142 = t141 . square () ; let t143 = t142 . square () ; let t144 = t143 * t141 ; let t145 = t144 * t140 ; let t146 = t145 . square () ; let t147 = t146 * t145 ; let t148 = t147 . square () ; let t149 = t148 * t145 ; let t150 = t149 * t141 ; let t151 = t150 . square () ; let t152 = t151 * t145 ; let t153 = t152 * t150 ; let t154 = t153 . square () ; let t155 = t154 * t153 ; let t156 = t155 . square () ; let t157 = t156 * t153 ; let t158 = t157 * t152 ; let t159 = t158 * t153 ; let t160 = t159 . square () ; let t161 = t160 * t159 ; let t162 = t161 * t158 ; let t163 = t162 * t159 ; let t164 = t163 . square () ; let t165 = t164 * t163 ; let t166 = t165 * t162 ; let t167 = t166 * t163 ; let t168 = t167 . square () ; let t169 = t168 . square () ; let t170 = t169 * t167 ; let t171 = t170 . square () ; let t172 = t170 . square () ; let t173 = t171 * t166 ; let t174 = t173 * t167 ; let t175 = t174 . square () ; let t176 = t175 * t174 ; let t177 = t176 . square () ; let t178 = t177 * t174 ; let t179 = t178 . square () ; let t180 = t179 . square () ; let t181 = t179 . square () ; let t182 = t180 * t173 ; let t183 = t182 . square () ; let t184 = t183 * t182 ; let t185 = t184 * t174 ; let t186 = t185 * t182 ; let t187 = t186 * t185 ; let t188 = t187 * t186 ; let t189 = t188 . square () ; let t190 = t189 * t188 ; let t191 = t190 . square () ; let t192 = t191 * t188 ; let t193 = t192 * t187 ; let t194 = t193 . square () ; let t195 = t194 * t188 ; let t196 = t195 . square () ; let t197 = t196 . square () ; let t198 = t197 * t193 ; let t199 = t198 . square () ; let t200 = t199 . square () ; let t201 = t200 * t198 ; let t202 = t201 * t195 ; let t203 = t202 . square () ; let t204 = t203 . square () ; let t205 = t204 * t202 ; let t206 = t205 * t198 ; let t207 = t206 * t202 ; let t208 = t207 * t206 ; let t209 = t208 * t207 ; let t210 = t209 . square () ; let t211 = t210 * t208 ; let t212 = t211 . square () ; let t213 = t212 * t209 ; let t214 = t213 . square () ; let t215 = t214 . square () ; let t216 = t215 . square () ; let t217 = t216 . square () ; let t218 = t217 . square () ; let t219 = t218 . square () ; let t220 = t219 . square () ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 . square () ; let t228 = t227 . square () ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 . square () ; let t234 = t233 . square () ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 . square () ; let t240 = t239 . square () ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 . square () ; let t245 = t244 . square () ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 . square () ; let t249 = t248 . square () ; let t250 = t249 . square () ; let t251 = t250 . square () ; let t252 = t251 . square () ; let t253 = t252 . square () ; let t254 = t253 . square () ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 . square () ; let t258 = t257 . square () ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 . square () ; let t262 = t261 . square () ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 . square () ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 . square () ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 . square () ; let t272 = t271 . square () ; let t273 = t272 . square () ; let t274 = t273 . square () ; let t275 = t274 . square () ; let t276 = t275 . square () ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 . square () ; let t281 = t280 . square () ; let t282 = t281 . square () ; let t283 = t282 . square () ; let t284 = t283 . square () ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 . square () ; let t289 = t288 . square () ; let t290 = t289 . square () ; let t291 = t290 . square () ; let t292 = t291 . square () ; let t293 = t292 . square () ; let t294 = t293 . square () ; let t295 = t294 . square () ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 . square () ; let t299 = t298 . square () ; let t300 = t299 . square () ; let t301 = t300 . square () ; let t302 = t301 . square () ; let t303 = t302 . square () ; let t304 = t303 . square () ; let t305 = t304 . square () ; let t306 = t305 . square () ; let t307 = t306 . square () ; let t308 = t307 . square () ; let t309 = t308 . square () ; let t310 = t309 . square () ; let t311 = t310 . square () ; let t312 = t311 . square () ; let t313 = t312 . square () ; let t314 = t313 . square () ; let t315 = t314 . square () ; let t316 = t315 . square () ; let t317 = t316 . square () ; let t318 = t317 . square () ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 . square () ; let t322 = t321 . square () ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 * t211 ; t338 } ; let mut v = S ; let mut x = * self * & w ; let mut b = x * & w ; let mut z = ROOT_OF_UNITY ; for max_v in (1 ..= S) . rev () { let mut k = 1 ; let mut tmp = b . square () ; let mut j_less_than_v : :: ff :: derive :: subtle :: Choice = 1 . into () ; for j in 2 .. max_v { let tmp_is_one = tmp . ct_eq (& Internal :: one ()) ; let squared = Internal :: conditional_select (& tmp , & z , tmp_is_one) . square () ; tmp = Internal :: conditional_select (& squared , & tmp , tmp_is_one) ; let new_z = Internal :: conditional_select (& z , & squared , tmp_is_one) ; j_less_than_v &= ! j . ct_eq (& v) ; k = u32 :: conditional_select (& j , & k , tmp_is_one) ; z = Internal :: conditional_select (& z , & new_z , j_less_than_v) ; } let result = x * & z ; x = Internal :: conditional_select (& result , & x , b . ct_eq (& Internal :: one ())) ; z = z . square () ; b *= & z ; v = k ; } :: ff :: derive :: subtle :: CtOption :: new (x , (x * & x) . ct_eq (self) ,) } } impl Internal { # [doc = r" Compares two elements in native representation. This is only used"] # [doc = r" internally."] # [inline (always)] fn cmp_native (& self , other : & Internal) -> :: core :: cmp :: Ordering { for (a , b) in self . 0 . iter () . rev () . zip (other . 0 . iter () . rev ()) { if a < b { return :: core :: cmp :: Ordering :: Less } else if a > b { return :: core :: cmp :: Ordering :: Greater } } :: core :: cmp :: Ordering :: Equal } # [doc = r" Determines if the element is really in the field. This is only used"] # [doc = r" internally."] # [inline (always)] fn is_valid (& self) -> bool { self . cmp_native (& MODULUS_LIMBS) == :: core :: cmp :: Ordering :: Less } # [inline (always)] fn add_nocarry (& mut self , other : & Internal) { let mut carry = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_carry) = :: ff :: derive :: adc (* a , * b , carry) ; * a = new_a ; carry = new_carry ; } } # [inline (always)] fn sub_noborrow (& mut self , other : & Internal) { let mut borrow = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_borrow) = :: ff :: derive :: sbb (* a , * b , borrow) ; * a = new_a ; borrow = new_borrow ; } } # [doc = r" Subtracts the modulus from this element if this element is not in the"] # [doc = r" field. Only used interally."] # [inline (always)] fn reduce (& mut self) { if ! self . is_valid () { self . sub_noborrow (& MODULUS_LIMBS) ; } } # [allow (clippy :: too_many_arguments)] # [inline (always)] fn mont_reduce (& mut self , r0 : u64 , mut r1 : u64 , mut r2 : u64 , mut r3 : u64 , mut r4 : u64 , mut r5 : u64 , mut r6 : u64 , mut r7 : u64 , mut r8 : u64 , mut r9 : u64) { let k = r0 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r0 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r1 , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r5 , carry2) = :: ff :: derive :: adc (r5 , 0 , carry) ; let k = r1 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r6 , carry2) = :: ff :: derive :: adc (r6 , carry2 , carry) ; let k = r2 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r7 , carry2) = :: ff :: derive :: adc (r7 , carry2 , carry) ; let k = r3 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r8 , carry2) = :: ff :: derive :: adc (r8 , carry2 , carry) ; let k = r4 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r9 , carry2) = :: ff :: derive :: adc (r9 , carry2 , carry) ; self . 0 [0usize] = r5 ; self . 0 [1usize] = r6 ; self . 0 [2usize] = r7 ; self . 0 [3usize] = r8 ; self . 0 [4usize] = r9 ; self . reduce () ; } }#[cfg(test)] pub(super) const MODULUS_STRING: &str = "115792089237316195423570985008687907852837564279074904382605163141518161494337";pub(super) const MODULUS_BYTES: &[u8] = &[65, 65, 54, 208, 140, 94, 210, 191, 59, 160, 72, 175, 230, 220, 174, 186, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255];#[cfg(test)] pub(super) const GENERATOR_STRING: &str = "7";