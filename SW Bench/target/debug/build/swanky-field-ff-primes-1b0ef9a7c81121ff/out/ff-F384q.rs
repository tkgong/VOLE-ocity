# [repr (transparent)] pub struct Internal ([u64 ; 7usize]) ; type REPR_BYTES = [u8 ; 56usize] ; type REPR_BITS = REPR_BYTES ; # [doc = r" This is the modulus m of the prime field"] const MODULUS : REPR_BITS = [115u8 , 41u8 , 197u8 , 204u8 , 106u8 , 25u8 , 236u8 , 236u8 , 122u8 , 167u8 , 176u8 , 72u8 , 178u8 , 13u8 , 26u8 , 88u8 , 223u8 , 45u8 , 55u8 , 244u8 , 129u8 , 77u8 , 99u8 , 199u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 ,] ; # [doc = r" This is the modulus m of the prime field in limb form"] const MODULUS_LIMBS : Internal = Internal ([17072048233947408755u64 , 6348401684107011962u64 , 14367412456785391071u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 0u64 ,]) ; # [doc = r" The number of bits needed to represent the modulus."] const MODULUS_BITS : u32 = 384u32 ; # [doc = r" The number of bits that must be shaved from the beginning of"] # [doc = r" the representation when randomly sampling."] const REPR_SHAVE_BITS : u32 = 64u32 ; # [doc = r" 2^{limbs*64} mod m"] const R : Internal = Internal ([0u64 , 1374695839762142861u64 , 12098342389602539653u64 , 4079331616924160544u64 , 0u64 , 0u64 , 0u64 ,]) ; # [doc = r" 2^{limbs*64*2} mod m"] const R2 : Internal = Internal ([4802803243809122321u64 , 4881047766694887661u64 , 883490074265464206u64 , 14741972603306567570u64 , 13763851512744812355u64 , 15279949475123764421u64 , 0u64 ,]) ; # [doc = r" -(m^{-1} mod m) mod m"] const INV : u64 = 7986114184663260229u64 ; # [doc = r" Multiplicative generator of `MODULUS` - 1 order, also quadratic"] # [doc = r" nonresidue."] const GENERATOR : Internal = Internal ([0u64 , 7672476881771162743u64 , 8507576517933634016u64 , 3720324426720843884u64 , 4u64 , 0u64 , 0u64 ,]) ; # [doc = r" 2^s * t = MODULUS - 1 with t odd"] const S : u32 = 1u32 ; # [doc = r" 2^s root of unity computed by GENERATOR^t"] const ROOT_OF_UNITY : Internal = Internal ([0u64 , 1374695839762142861u64 , 12098342389602539653u64 , 4079331616924160544u64 , 0u64 , 0u64 , 0u64 ,]) ; # [derive (Copy , Clone)] pub struct InternalRepr (pub [u8 ; 56usize]) ; impl :: ff :: derive :: subtle :: ConstantTimeEq for InternalRepr { fn ct_eq (& self , other : & InternalRepr) -> :: ff :: derive :: subtle :: Choice { self . 0 . iter () . zip (other . 0 . iter ()) . map (| (a , b) | a . ct_eq (b)) . fold (1 . into () , | acc , x | acc & x) } } impl :: core :: cmp :: PartialEq for InternalRepr { fn eq (& self , other : & InternalRepr) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for InternalRepr { } impl :: core :: default :: Default for InternalRepr { fn default () -> InternalRepr { InternalRepr ([0u8 ; 56usize]) } } impl :: core :: fmt :: Debug for InternalRepr { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "0x") ? ; for i in self . 0 . iter () . rev () { write ! (f , "{:02x}" , * i) ? ; } Ok (()) } } impl AsRef < [u8] > for InternalRepr { # [inline (always)] fn as_ref (& self) -> & [u8] { & self . 0 } } impl AsMut < [u8] > for InternalRepr { # [inline (always)] fn as_mut (& mut self) -> & mut [u8] { & mut self . 0 } } impl :: core :: marker :: Copy for Internal { } impl :: core :: clone :: Clone for Internal { fn clone (& self) -> Internal { * self } } impl :: core :: default :: Default for Internal { fn default () -> Internal { use :: ff :: Field ; Internal :: zero () } } impl :: ff :: derive :: subtle :: ConstantTimeEq for Internal { fn ct_eq (& self , other : & Internal) -> :: ff :: derive :: subtle :: Choice { use :: ff :: PrimeField ; self . to_repr () . ct_eq (& other . to_repr ()) } } impl :: core :: cmp :: PartialEq for Internal { fn eq (& self , other : & Internal) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for Internal { } impl :: core :: fmt :: Debug for Internal { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use :: ff :: PrimeField ; write ! (f , "{}({:?})" , stringify ! (Internal) , self . to_repr ()) } } # [doc = r" Elements are ordered lexicographically."] impl Ord for Internal { # [inline (always)] fn cmp (& self , other : & Internal) -> :: core :: cmp :: Ordering { let mut a = * self ; a . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , self . 0 [5usize] , self . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; let mut b = * other ; b . mont_reduce (other . 0 [0usize] , other . 0 [1usize] , other . 0 [2usize] , other . 0 [3usize] , other . 0 [4usize] , other . 0 [5usize] , other . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; a . cmp_native (& b) } } impl PartialOrd for Internal { # [inline (always)] fn partial_cmp (& self , other : & Internal) -> Option < :: core :: cmp :: Ordering > { Some (self . cmp (other)) } } impl From < u64 > for Internal { # [inline (always)] fn from (val : u64) -> Internal { let mut raw = [0u64 ; 7usize] ; raw [0] = val ; Internal (raw) * R2 } } impl From < Internal > for InternalRepr { fn from (e : Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl < 'a > From < & 'a Internal > for InternalRepr { fn from (e : & 'a Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl :: ff :: derive :: subtle :: ConditionallySelectable for Internal { fn conditional_select (a : & Internal , b : & Internal , choice : :: ff :: derive :: subtle :: Choice) -> Internal { let mut res = [0u64 ; 7usize] ; for i in 0 .. 7usize { res [i] = u64 :: conditional_select (& a . 0 [i] , & b . 0 [i] , choice) ; } Internal (res) } } impl :: core :: ops :: Neg for Internal { type Output = Internal ; # [inline] fn neg (self) -> Internal { use :: ff :: Field ; let mut ret = self ; if ! ret . is_zero_vartime () { let mut tmp = MODULUS_LIMBS ; tmp . sub_noborrow (& ret) ; ret = tmp ; } ret } } impl < 'r > :: core :: ops :: Add < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn add (self , other : & Internal) -> Internal { use :: core :: ops :: AddAssign ; let mut ret = self ; ret . add_assign (other) ; ret } } impl :: core :: ops :: Add for Internal { type Output = Internal ; # [inline] fn add (self , other : Internal) -> Self { self + & other } } impl < 'r > :: core :: ops :: AddAssign < & 'r Internal > for Internal { # [inline] fn add_assign (& mut self , other : & Internal) { self . add_nocarry (other) ; self . reduce () ; } } impl :: core :: ops :: AddAssign for Internal { # [inline] fn add_assign (& mut self , other : Internal) { self . add_assign (& other) ; } } impl < 'r > :: core :: ops :: Sub < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn sub (self , other : & Internal) -> Self { use :: core :: ops :: SubAssign ; let mut ret = self ; ret . sub_assign (other) ; ret } } impl :: core :: ops :: Sub for Internal { type Output = Internal ; # [inline] fn sub (self , other : Internal) -> Self { self - & other } } impl < 'r > :: core :: ops :: SubAssign < & 'r Internal > for Internal { # [inline] fn sub_assign (& mut self , other : & Internal) { if other . cmp_native (self) == :: core :: cmp :: Ordering :: Greater { self . add_nocarry (& MODULUS_LIMBS) ; } self . sub_noborrow (other) ; } } impl :: core :: ops :: SubAssign for Internal { # [inline] fn sub_assign (& mut self , other : Internal) { self . sub_assign (& other) ; } } impl < 'r > :: core :: ops :: Mul < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn mul (self , other : & Internal) -> Self { use :: core :: ops :: MulAssign ; let mut ret = self ; ret . mul_assign (other) ; ret } } impl :: core :: ops :: Mul for Internal { type Output = Internal ; # [inline] fn mul (self , other : Internal) -> Self { self * & other } } impl < 'r > :: core :: ops :: MulAssign < & 'r Internal > for Internal { # [inline] fn mul_assign (& mut self , other : & Internal) { let carry = 0 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [0usize] , carry) ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [4usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [5usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [6usize] , carry) ; let r7 = carry ; let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (r1 , self . 0 [1usize] , other . 0 [0usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , other . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , other . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , other . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [1usize] , other . 0 [4usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [1usize] , other . 0 [5usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [1usize] , other . 0 [6usize] , carry) ; let r8 = carry ; let carry = 0 ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [2usize] , other . 0 [0usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [2usize] , other . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , other . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , other . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [2usize] , other . 0 [4usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [2usize] , other . 0 [5usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [2usize] , other . 0 [6usize] , carry) ; let r9 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [3usize] , other . 0 [0usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [3usize] , other . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [3usize] , other . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , other . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [3usize] , other . 0 [4usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [3usize] , other . 0 [5usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [3usize] , other . 0 [6usize] , carry) ; let r10 = carry ; let carry = 0 ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [4usize] , other . 0 [0usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [4usize] , other . 0 [1usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [4usize] , other . 0 [2usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [4usize] , other . 0 [3usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [4usize] , other . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [4usize] , other . 0 [5usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [4usize] , other . 0 [6usize] , carry) ; let r11 = carry ; let carry = 0 ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [5usize] , other . 0 [0usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [5usize] , other . 0 [1usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [5usize] , other . 0 [2usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [5usize] , other . 0 [3usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [5usize] , other . 0 [4usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [5usize] , other . 0 [5usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , self . 0 [5usize] , other . 0 [6usize] , carry) ; let r12 = carry ; let carry = 0 ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [6usize] , other . 0 [0usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [6usize] , other . 0 [1usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [6usize] , other . 0 [2usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [6usize] , other . 0 [3usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [6usize] , other . 0 [4usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , self . 0 [6usize] , other . 0 [5usize] , carry) ; let (r12 , carry) = :: ff :: derive :: mac (r12 , self . 0 [6usize] , other . 0 [6usize] , carry) ; let r13 = carry ; self . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r10 , r11 , r12 , r13) ; } } impl :: core :: ops :: MulAssign for Internal { # [inline] fn mul_assign (& mut self , other : Internal) { self . mul_assign (& other) ; } } impl :: ff :: PrimeField for Internal { type Repr = InternalRepr ; fn from_repr (r : InternalRepr) -> :: ff :: derive :: subtle :: CtOption < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 7usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; let borrow = r . 0 . iter () . zip (MODULUS_LIMBS . 0 . iter ()) . fold (0 , | borrow , (a , b) | { :: ff :: derive :: sbb (* a , * b , borrow) . 1 }) ; let is_some = :: ff :: derive :: subtle :: Choice :: from ((borrow as u8) & 1) ; :: ff :: derive :: subtle :: CtOption :: new (r * & R2 , is_some) } fn from_repr_vartime (r : InternalRepr) -> Option < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 7usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; if r . is_valid () { Some (r * R2) } else { None } } fn to_repr (& self) -> InternalRepr { use :: ff :: derive :: byteorder :: ByteOrder ; let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , self . 0 [5usize] , self . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; let mut repr = [0u8 ; 56usize] ; :: ff :: derive :: byteorder :: LittleEndian :: write_u64_into (& r . 0 , & mut repr [..]) ; InternalRepr (repr) } # [inline (always)] fn is_odd (& self) -> :: ff :: derive :: subtle :: Choice { let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , self . 0 [5usize] , self . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; :: ff :: derive :: subtle :: Choice :: from ((r . 0 [0] & 1) as u8) } const NUM_BITS : u32 = MODULUS_BITS ; const CAPACITY : u32 = Self :: NUM_BITS - 1 ; fn multiplicative_generator () -> Self { GENERATOR } const MULTIPLICATIVE_GENERATOR : Self = GENERATOR ; const S : u32 = S ; fn root_of_unity () -> Self { ROOT_OF_UNITY } } impl :: ff :: Field for Internal { # [doc = r" Computes a uniformly random element using rejection sampling."] fn random (mut rng : impl :: ff :: derive :: rand_core :: RngCore) -> Self { loop { let mut tmp = { let mut repr = [0u64 ; 7usize] ; for i in 0 .. 7usize { repr [i] = rng . next_u64 () ; } Internal (repr) } ; tmp . 0 . as_mut () [6usize] &= 0xffffffffffffffffu64 . checked_shr (REPR_SHAVE_BITS) . unwrap_or (0) ; if tmp . is_valid () { return tmp } } } # [inline] fn zero () -> Self { Internal ([0 ; 7usize]) } const ZERO : Self = Internal ([0 ; 7usize]) ; # [inline] fn one () -> Self { R } const ONE : Self = R ; # [inline] fn is_zero (& self) -> :: ff :: derive :: subtle :: Choice { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (& Self :: zero ()) } # [inline] fn is_zero_vartime (& self) -> bool { self . 0 . iter () . all (| & e | e == 0) } # [inline] fn double (& self) -> Self { let mut ret = * self ; let mut last = 0 ; for i in & mut ret . 0 { let tmp = * i >> 63 ; * i <<= 1 ; * i |= last ; last = tmp ; } ret . reduce () ; ret } fn invert (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let inv = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 . square () ; let t3 = t2 . square () ; let t4 = t3 . square () ; let t5 = t4 * t0 ; let t6 = t5 . square () ; let t7 = t6 . square () ; let t8 = t7 . square () ; let t9 = t8 . square () ; let t10 = t9 * t1 ; let t11 = t10 . square () ; let t12 = t11 * t10 ; let t13 = t12 * t0 ; let t14 = t13 . square () ; let t15 = t14 * t13 ; let t16 = t15 * t10 ; let t17 = t16 . square () ; let t18 = t17 . square () ; let t19 = t18 * t13 ; let t20 = t19 . square () ; let t21 = t20 * t16 ; let t22 = t21 . square () ; let t23 = t22 * t19 ; let t24 = t23 * t21 ; let t25 = t24 * t23 ; let t26 = t25 . square () ; let t27 = t26 * t24 ; let t28 = t27 . square () ; let t29 = t28 * t27 ; let t30 = t29 . square () ; let t31 = t29 . square () ; let t32 = t30 . square () ; let t33 = t32 . square () ; let t34 = t33 * t27 ; let t35 = t34 * t25 ; let t36 = t35 . square () ; let t37 = t36 * t27 ; let t38 = t37 * t35 ; let t39 = t38 . square () ; let t40 = t39 * t38 ; let t41 = t40 * t37 ; let t42 = t41 * t38 ; let t43 = t42 * t41 ; let t44 = t43 . square () ; let t45 = t44 . square () ; let t46 = t45 * t43 ; let t47 = t46 . square () ; let t48 = t47 * t43 ; let t49 = t48 . square () ; let t50 = t49 * t48 ; let t51 = t50 * t43 ; let t52 = t51 . square () ; let t53 = t52 . square () ; let t54 = t53 . square () ; let t55 = t54 . square () ; let t56 = t55 * t48 ; let t57 = t56 * t42 ; let t58 = t57 . square () ; let t59 = t58 . square () ; let t60 = t59 * t57 ; let t61 = t60 * t43 ; let t62 = t61 . square () ; let t63 = t62 * t57 ; let t64 = t63 . square () ; let t65 = t64 * t63 ; let t66 = t65 * t61 ; let t67 = t66 . square () ; let t68 = t67 . square () ; let t69 = t68 . square () ; let t70 = t69 . square () ; let t71 = t70 . square () ; let t72 = t71 * t66 ; let t73 = t72 * t63 ; let t74 = t73 . square () ; let t75 = t74 * t66 ; let t76 = t75 * t73 ; let t77 = t76 * t75 ; let t78 = t77 . square () ; let t79 = t78 . square () ; let t80 = t79 . square () ; let t81 = t80 * t77 ; let t82 = t81 . square () ; let t83 = t82 . square () ; let t84 = t82 . square () ; let t85 = t83 * t76 ; let t86 = t85 * t77 ; let t87 = t86 . square () ; let t88 = t87 * t85 ; let t89 = t88 . square () ; let t90 = t89 * t88 ; let t91 = t90 . square () ; let t92 = t91 * t88 ; let t93 = t92 * t86 ; let t94 = t93 . square () ; let t95 = t94 * t88 ; let t96 = t95 . square () ; let t97 = t96 * t95 ; let t98 = t97 . square () ; let t99 = t97 . square () ; let t100 = t98 * t93 ; let t101 = t100 . square () ; let t102 = t101 . square () ; let t103 = t102 * t95 ; let t104 = t103 * t100 ; let t105 = t104 . square () ; let t106 = t105 . square () ; let t107 = t105 . square () ; let t108 = t106 . square () ; let t109 = t108 * t106 ; let t110 = t109 * t105 ; let t111 = t110 . square () ; let t112 = t111 . square () ; let t113 = t112 . square () ; let t114 = t113 * t106 ; let t115 = t114 * t103 ; let t116 = t115 . square () ; let t117 = t116 * t104 ; let t118 = t117 . square () ; let t119 = t118 . square () ; let t120 = t119 . square () ; let t121 = t120 * t117 ; let t122 = t121 * t115 ; let t123 = t122 * t117 ; let t124 = t123 . square () ; let t125 = t124 * t123 ; let t126 = t125 . square () ; let t127 = t126 * t123 ; let t128 = t127 . square () ; let t129 = t128 . square () ; let t130 = t129 * t125 ; let t131 = t130 * t122 ; let t132 = t131 * t123 ; let t133 = t132 . square () ; let t134 = t133 * t131 ; let t135 = t134 * t132 ; let t136 = t135 * t134 ; let t137 = t136 . square () ; let t138 = t137 . square () ; let t139 = t138 * t135 ; let t140 = t139 * t136 ; let t141 = t140 . square () ; let t142 = t141 * t139 ; let t143 = t142 * t140 ; let t144 = t143 . square () ; let t145 = t144 * t142 ; let t146 = t145 . square () ; let t147 = t146 * t143 ; let t148 = t147 . square () ; let t149 = t148 . square () ; let t150 = t149 * t148 ; let t151 = t149 * t148 ; let t152 = t150 . square () ; let t153 = t152 . square () ; let t154 = t153 * t148 ; let t155 = t154 * t145 ; let t156 = t155 . square () ; let t157 = t156 * t155 ; let t158 = t157 . square () ; let t159 = t157 . square () ; let t160 = t158 . square () ; let t161 = t160 * t155 ; let t162 = t161 * t147 ; let t163 = t162 . square () ; let t164 = t163 * t162 ; let t165 = t164 * t155 ; let t166 = t165 . square () ; let t167 = t166 . square () ; let t168 = t167 . square () ; let t169 = t168 . square () ; let t170 = t169 . square () ; let t171 = t170 * t165 ; let t172 = t171 * t162 ; let t173 = t172 * t165 ; let t174 = t173 . square () ; let t175 = t174 * t173 ; let t176 = t175 * t172 ; let t177 = t176 * t173 ; let t178 = t177 * t176 ; let t179 = t178 . square () ; let t180 = t179 * t178 ; let t181 = t180 * t177 ; let t182 = t181 . square () ; let t183 = t182 * t181 ; let t184 = t183 . square () ; let t185 = t183 . square () ; let t186 = t184 * t178 ; let t187 = t186 * t181 ; let t188 = t187 . square () ; let t189 = t188 * t186 ; let t190 = t189 * t187 ; let t191 = t190 * t189 ; let t192 = t191 * t190 ; let t193 = t192 * t191 ; let t194 = t193 . square () ; let t195 = t194 * t193 ; let t196 = t195 . square () ; let t197 = t196 * t193 ; let t198 = t197 * t192 ; let t199 = t198 . square () ; let t200 = t199 . square () ; let t201 = t200 . square () ; let t202 = t201 . square () ; let t203 = t202 . square () ; let t204 = t203 * t193 ; let t205 = t204 * t198 ; let t206 = t205 . square () ; let t207 = t206 . square () ; let t208 = t207 . square () ; let t209 = t208 . square () ; let t210 = t209 * t204 ; let t211 = t210 . square () ; let t212 = t211 * t205 ; let t213 = t212 * t210 ; let t214 = t213 . square () ; let t215 = t214 * t213 ; let t216 = t215 . square () ; let t217 = t215 . square () ; let t218 = t216 * t212 ; let t219 = t218 . square () ; let t220 = t219 * t213 ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 * t220 ; let t224 = t223 * t218 ; let t225 = t224 . square () ; let t226 = t225 * t220 ; let t227 = t226 . square () ; let t228 = t227 * t224 ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 * t229 ; let t234 = t233 * t228 ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 * t229 ; let t240 = t239 * t226 ; let t241 = t240 * t228 ; let t242 = t241 * t240 ; let t243 = t242 * t241 ; let t244 = t243 . square () ; let t245 = t244 * t242 ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 * t245 ; let t249 = t248 * t243 ; let t250 = t249 * t245 ; let t251 = t250 * t249 ; let t252 = t251 . square () ; let t253 = t252 * t251 ; let t254 = t253 . square () ; let t255 = t253 . square () ; let t256 = t254 . square () ; let t257 = t256 * t251 ; let t258 = t257 * t250 ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 * t258 ; let t262 = t261 . square () ; let t263 = t261 . square () ; let t264 = t262 * t251 ; let t265 = t264 * t258 ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 * t264 ; let t269 = t268 . square () ; let t270 = t269 * t268 ; let t271 = t270 . square () ; let t272 = t270 . square () ; let t273 = t271 . square () ; let t274 = t273 * t268 ; let t275 = t274 * t265 ; let t276 = t275 * t268 ; let t277 = t276 . square () ; let t278 = t277 * t275 ; let t279 = t278 * t276 ; let t280 = t279 * t278 ; let t281 = t280 * t279 ; let t282 = t281 * t280 ; let t283 = t282 * t281 ; let t284 = t283 * t282 ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 * t283 ; let t289 = t288 * t284 ; let t290 = t289 . square () ; let t291 = t290 * t289 ; let t292 = t291 . square () ; let t293 = t291 . square () ; let t294 = t292 * t288 ; let t295 = t294 * t289 ; let t296 = t295 * t294 ; let t297 = t296 . square () ; let t298 = t297 * t295 ; let t299 = t298 . square () ; let t300 = t299 * t298 ; let t301 = t300 * t296 ; let t302 = t301 . square () ; let t303 = t302 . square () ; let t304 = t303 * t298 ; let t305 = t304 * t301 ; let t306 = t305 . square () ; let t307 = t306 . square () ; let t308 = t307 * t305 ; let t309 = t308 * t304 ; let t310 = t309 . square () ; let t311 = t310 * t309 ; let t312 = t311 . square () ; let t313 = t312 * t309 ; let t314 = t313 * t305 ; let t315 = t314 . square () ; let t316 = t315 . square () ; let t317 = t316 . square () ; let t318 = t317 . square () ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 . square () ; let t322 = t321 . square () ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 . square () ; let t339 = t338 . square () ; let t340 = t339 . square () ; let t341 = t340 . square () ; let t342 = t341 . square () ; let t343 = t342 . square () ; let t344 = t343 . square () ; let t345 = t344 . square () ; let t346 = t345 . square () ; let t347 = t346 . square () ; let t348 = t347 . square () ; let t349 = t348 . square () ; let t350 = t349 . square () ; let t351 = t350 . square () ; let t352 = t351 . square () ; let t353 = t352 . square () ; let t354 = t353 . square () ; let t355 = t354 . square () ; let t356 = t355 . square () ; let t357 = t356 . square () ; let t358 = t357 . square () ; let t359 = t358 . square () ; let t360 = t359 . square () ; let t361 = t360 . square () ; let t362 = t361 . square () ; let t363 = t362 . square () ; let t364 = t363 . square () ; let t365 = t364 . square () ; let t366 = t365 . square () ; let t367 = t366 . square () ; let t368 = t367 . square () ; let t369 = t368 . square () ; let t370 = t369 . square () ; let t371 = t370 . square () ; let t372 = t371 . square () ; let t373 = t372 . square () ; let t374 = t373 . square () ; let t375 = t374 . square () ; let t376 = t375 . square () ; let t377 = t376 . square () ; let t378 = t377 . square () ; let t379 = t378 . square () ; let t380 = t379 . square () ; let t381 = t380 . square () ; let t382 = t381 . square () ; let t383 = t382 . square () ; let t384 = t383 . square () ; let t385 = t384 . square () ; let t386 = t385 . square () ; let t387 = t386 . square () ; let t388 = t387 . square () ; let t389 = t388 . square () ; let t390 = t389 . square () ; let t391 = t390 . square () ; let t392 = t391 . square () ; let t393 = t392 . square () ; let t394 = t393 . square () ; let t395 = t394 . square () ; let t396 = t395 . square () ; let t397 = t396 . square () ; let t398 = t397 . square () ; let t399 = t398 . square () ; let t400 = t399 . square () ; let t401 = t400 . square () ; let t402 = t401 . square () ; let t403 = t402 . square () ; let t404 = t403 . square () ; let t405 = t404 . square () ; let t406 = t405 . square () ; let t407 = t406 . square () ; let t408 = t407 . square () ; let t409 = t408 . square () ; let t410 = t409 . square () ; let t411 = t410 . square () ; let t412 = t411 . square () ; let t413 = t412 . square () ; let t414 = t413 . square () ; let t415 = t414 . square () ; let t416 = t415 . square () ; let t417 = t416 . square () ; let t418 = t417 . square () ; let t419 = t418 . square () ; let t420 = t419 . square () ; let t421 = t420 . square () ; let t422 = t421 . square () ; let t423 = t422 . square () ; let t424 = t423 . square () ; let t425 = t424 . square () ; let t426 = t425 . square () ; let t427 = t426 . square () ; let t428 = t427 . square () ; let t429 = t428 . square () ; let t430 = t429 . square () ; let t431 = t430 . square () ; let t432 = t431 . square () ; let t433 = t432 . square () ; let t434 = t433 . square () ; let t435 = t434 . square () ; let t436 = t435 . square () ; let t437 = t436 . square () ; let t438 = t437 . square () ; let t439 = t438 . square () ; let t440 = t439 . square () ; let t441 = t440 . square () ; let t442 = t441 . square () ; let t443 = t442 . square () ; let t444 = t443 . square () ; let t445 = t444 . square () ; let t446 = t445 . square () ; let t447 = t446 . square () ; let t448 = t447 . square () ; let t449 = t448 . square () ; let t450 = t449 . square () ; let t451 = t450 . square () ; let t452 = t451 . square () ; let t453 = t452 . square () ; let t454 = t453 . square () ; let t455 = t454 . square () ; let t456 = t455 . square () ; let t457 = t456 . square () ; let t458 = t457 . square () ; let t459 = t458 . square () ; let t460 = t459 . square () ; let t461 = t460 . square () ; let t462 = t461 . square () ; let t463 = t462 . square () ; let t464 = t463 . square () ; let t465 = t464 . square () ; let t466 = t465 . square () ; let t467 = t466 . square () ; let t468 = t467 . square () ; let t469 = t468 . square () ; let t470 = t469 . square () ; let t471 = t470 . square () ; let t472 = t471 . square () ; let t473 = t472 . square () ; let t474 = t473 . square () ; let t475 = t474 . square () ; let t476 = t475 . square () ; let t477 = t476 . square () ; let t478 = t477 . square () ; let t479 = t478 . square () ; let t480 = t479 . square () ; let t481 = t480 . square () ; let t482 = t481 . square () ; let t483 = t482 . square () ; let t484 = t483 . square () ; let t485 = t484 . square () ; let t486 = t485 . square () ; let t487 = t486 . square () ; let t488 = t487 . square () ; let t489 = t488 . square () ; let t490 = t489 . square () ; let t491 = t490 . square () ; let t492 = t491 . square () ; let t493 = t492 . square () ; let t494 = t493 . square () ; let t495 = t494 . square () ; let t496 = t495 . square () ; let t497 = t496 . square () ; let t498 = t497 . square () ; let t499 = t498 . square () ; let t500 = t499 . square () ; let t501 = t500 . square () ; let t502 = t501 . square () ; let t503 = t502 . square () ; let t504 = t503 . square () ; let t505 = t504 . square () ; let t506 = t505 * t309 ; t506 } ; :: ff :: derive :: subtle :: CtOption :: new (inv , ! self . ct_eq (& Internal :: zero ())) } # [inline] fn square (& self) -> Self { let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [4usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [5usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [6usize] , carry) ; let r7 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , self . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , self . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [1usize] , self . 0 [4usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [1usize] , self . 0 [5usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [1usize] , self . 0 [6usize] , carry) ; let r8 = carry ; let carry = 0 ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , self . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [2usize] , self . 0 [4usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [2usize] , self . 0 [5usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [2usize] , self . 0 [6usize] , carry) ; let r9 = carry ; let carry = 0 ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [3usize] , self . 0 [4usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [3usize] , self . 0 [5usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [3usize] , self . 0 [6usize] , carry) ; let r10 = carry ; let carry = 0 ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [4usize] , self . 0 [5usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [4usize] , self . 0 [6usize] , carry) ; let r11 = carry ; let carry = 0 ; let (r11 , carry) = :: ff :: derive :: mac (r11 , self . 0 [5usize] , self . 0 [6usize] , carry) ; let r12 = carry ; let r13 = r12 >> 63 ; let r12 = (r12 << 1) | (r11 >> 63) ; let r11 = (r11 << 1) | (r10 >> 63) ; let r10 = (r10 << 1) | (r9 >> 63) ; let r9 = (r9 << 1) | (r8 >> 63) ; let r8 = (r8 << 1) | (r7 >> 63) ; let r7 = (r7 << 1) | (r6 >> 63) ; let r6 = (r6 << 1) | (r5 >> 63) ; let r5 = (r5 << 1) | (r4 >> 63) ; let r4 = (r4 << 1) | (r3 >> 63) ; let r3 = (r3 << 1) | (r2 >> 63) ; let r2 = (r2 << 1) | (r1 >> 63) ; let r1 = r1 << 1 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [0usize] , 0) ; let (r1 , carry) = :: ff :: derive :: adc (r1 , 0 , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , self . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: adc (r3 , 0 , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , self . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: adc (r5 , 0 , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , self . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: adc (r7 , 0 , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [4usize] , self . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: adc (r9 , 0 , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [5usize] , self . 0 [5usize] , carry) ; let (r11 , carry) = :: ff :: derive :: adc (r11 , 0 , carry) ; let (r12 , carry) = :: ff :: derive :: mac (r12 , self . 0 [6usize] , self . 0 [6usize] , carry) ; let (r13 , carry) = :: ff :: derive :: adc (r13 , 0 , carry) ; let mut ret = * self ; ret . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r10 , r11 , r12 , r13) ; ret } fn sqrt (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let sqrt = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 . square () ; let t3 = t2 * t1 ; let t4 = t3 * t0 ; let t5 = t4 * t1 ; let t6 = t5 . square () ; let t7 = t6 * t5 ; let t8 = t7 . square () ; let t9 = t8 * t5 ; let t10 = t9 * t4 ; let t11 = t10 . square () ; let t12 = t11 . square () ; let t13 = t12 * t10 ; let t14 = t13 * t5 ; let t15 = t14 * t10 ; let t16 = t15 * t14 ; let t17 = t16 . square () ; let t18 = t17 * t15 ; let t19 = t18 * t16 ; let t20 = t19 . square () ; let t21 = t20 . square () ; let t22 = t21 . square () ; let t23 = t22 . square () ; let t24 = t23 * t18 ; let t25 = t24 * t19 ; let t26 = t25 . square () ; let t27 = t26 . square () ; let t28 = t27 * t24 ; let t29 = t28 * t25 ; let t30 = t29 . square () ; let t31 = t30 * t28 ; let t32 = t31 . square () ; let t33 = t32 . square () ; let t34 = t33 * t31 ; let t35 = t34 * t29 ; let t36 = t35 . square () ; let t37 = t36 * t35 ; let t38 = t37 * t31 ; let t39 = t38 . square () ; let t40 = t39 * t38 ; let t41 = t40 * t35 ; let t42 = t41 * t38 ; let t43 = t42 * t41 ; let t44 = t43 * t42 ; let t45 = t44 . square () ; let t46 = t45 . square () ; let t47 = t46 . square () ; let t48 = t47 * t44 ; let t49 = t48 * t43 ; let t50 = t49 . square () ; let t51 = t50 . square () ; let t52 = t51 * t44 ; let t53 = t52 . square () ; let t54 = t53 * t49 ; let t55 = t54 . square () ; let t56 = t55 * t54 ; let t57 = t56 . square () ; let t58 = t56 . square () ; let t59 = t57 * t52 ; let t60 = t59 . square () ; let t61 = t60 * t54 ; let t62 = t61 * t59 ; let t63 = t62 * t61 ; let t64 = t63 . square () ; let t65 = t64 * t63 ; let t66 = t65 * t62 ; let t67 = t66 . square () ; let t68 = t67 . square () ; let t69 = t68 * t66 ; let t70 = t69 . square () ; let t71 = t69 . square () ; let t72 = t70 * t63 ; let t73 = t72 * t66 ; let t74 = t73 . square () ; let t75 = t74 * t72 ; let t76 = t75 * t73 ; let t77 = t76 . square () ; let t78 = t77 . square () ; let t79 = t78 * t77 ; let t80 = t79 . square () ; let t81 = t79 . square () ; let t82 = t79 . square () ; let t83 = t80 . square () ; let t84 = t83 . square () ; let t85 = t84 * t77 ; let t86 = t85 * t75 ; let t87 = t86 * t76 ; let t88 = t87 . square () ; let t89 = t88 * t87 ; let t90 = t89 . square () ; let t91 = t90 * t87 ; let t92 = t91 . square () ; let t93 = t92 * t87 ; let t94 = t93 * t86 ; let t95 = t94 * t87 ; let t96 = t95 . square () ; let t97 = t96 * t95 ; let t98 = t96 . square () ; let t99 = t98 . square () ; let t100 = t99 . square () ; let t101 = t100 * t97 ; let t102 = t101 * t94 ; let t103 = t102 * t95 ; let t104 = t103 . square () ; let t105 = t104 * t103 ; let t106 = t105 . square () ; let t107 = t105 . square () ; let t108 = t106 * t102 ; let t109 = t108 * t103 ; let t110 = t109 . square () ; let t111 = t110 * t108 ; let t112 = t111 . square () ; let t113 = t112 . square () ; let t114 = t113 . square () ; let t115 = t114 * t111 ; let t116 = t115 * t109 ; let t117 = t116 * t111 ; let t118 = t117 . square () ; let t119 = t118 . square () ; let t120 = t119 * t116 ; let t121 = t120 . square () ; let t122 = t121 * t120 ; let t123 = t122 . square () ; let t124 = t123 * t120 ; let t125 = t124 . square () ; let t126 = t124 . square () ; let t127 = t125 * t117 ; let t128 = t127 . square () ; let t129 = t128 . square () ; let t130 = t129 . square () ; let t131 = t130 * t128 ; let t132 = t131 * t127 ; let t133 = t132 . square () ; let t134 = t133 . square () ; let t135 = t134 * t128 ; let t136 = t135 * t120 ; let t137 = t136 * t127 ; let t138 = t137 * t136 ; let t139 = t138 . square () ; let t140 = t139 . square () ; let t141 = t140 * t138 ; let t142 = t141 . square () ; let t143 = t142 * t138 ; let t144 = t143 * t137 ; let t145 = t144 . square () ; let t146 = t145 . square () ; let t147 = t146 . square () ; let t148 = t147 * t144 ; let t149 = t148 * t138 ; let t150 = t149 * t144 ; let t151 = t150 . square () ; let t152 = t151 * t149 ; let t153 = t152 * t150 ; let t154 = t153 . square () ; let t155 = t154 . square () ; let t156 = t155 * t152 ; let t157 = t156 * t153 ; let t158 = t157 . square () ; let t159 = t158 . square () ; let t160 = t159 * t157 ; let t161 = t160 * t156 ; let t162 = t161 * t157 ; let t163 = t162 . square () ; let t164 = t163 * t162 ; let t165 = t164 . square () ; let t166 = t164 . square () ; let t167 = t165 * t161 ; let t168 = t167 . square () ; let t169 = t168 . square () ; let t170 = t169 * t167 ; let t171 = t170 . square () ; let t172 = t170 . square () ; let t173 = t171 * t162 ; let t174 = t173 . square () ; let t175 = t174 . square () ; let t176 = t175 * t167 ; let t177 = t176 . square () ; let t178 = t177 * t173 ; let t179 = t178 * t176 ; let t180 = t179 . square () ; let t181 = t180 . square () ; let t182 = t181 . square () ; let t183 = t182 * t178 ; let t184 = t183 . square () ; let t185 = t184 * t179 ; let t186 = t185 * t183 ; let t187 = t186 * t185 ; let t188 = t187 . square () ; let t189 = t188 * t186 ; let t190 = t189 . square () ; let t191 = t190 * t187 ; let t192 = t191 . square () ; let t193 = t192 * t191 ; let t194 = t193 . square () ; let t195 = t194 * t191 ; let t196 = t195 . square () ; let t197 = t196 * t191 ; let t198 = t197 * t189 ; let t199 = t198 * t191 ; let t200 = t199 . square () ; let t201 = t200 . square () ; let t202 = t201 . square () ; let t203 = t202 . square () ; let t204 = t203 * t198 ; let t205 = t204 * t199 ; let t206 = t205 * t204 ; let t207 = t206 . square () ; let t208 = t207 * t206 ; let t209 = t208 * t205 ; let t210 = t209 * t206 ; let t211 = t210 . square () ; let t212 = t211 * t209 ; let t213 = t212 . square () ; let t214 = t213 . square () ; let t215 = t214 . square () ; let t216 = t215 * t210 ; let t217 = t216 . square () ; let t218 = t217 * t216 ; let t219 = t218 * t212 ; let t220 = t219 . square () ; let t221 = t220 * t216 ; let t222 = t221 * t219 ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 * t222 ; let t228 = t227 * t221 ; let t229 = t228 * t222 ; let t230 = t229 . square () ; let t231 = t230 * t229 ; let t232 = t231 . square () ; let t233 = t231 . square () ; let t234 = t232 . square () ; let t235 = t234 * t229 ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t236 . square () ; let t239 = t237 * t228 ; let t240 = t239 * t229 ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 * t239 ; let t245 = t244 * t240 ; let t246 = t245 * t244 ; let t247 = t246 * t245 ; let t248 = t247 * t246 ; let t249 = t248 . square () ; let t250 = t249 * t247 ; let t251 = t250 . square () ; let t252 = t251 * t248 ; let t253 = t252 * t250 ; let t254 = t253 * t252 ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 * t254 ; let t258 = t257 * t253 ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 * t258 ; let t262 = t261 * t254 ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 * t258 ; let t266 = t265 . square () ; let t267 = t266 * t265 ; let t268 = t267 * t262 ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 * t268 ; let t272 = t271 . square () ; let t273 = t271 . square () ; let t274 = t272 * t265 ; let t275 = t274 . square () ; let t276 = t275 * t268 ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 * t276 ; let t281 = t280 * t274 ; let t282 = t281 * t276 ; let t283 = t282 . square () ; let t284 = t283 * t282 ; let t285 = t284 * t281 ; let t286 = t285 . square () ; let t287 = t286 * t282 ; let t288 = t287 . square () ; let t289 = t288 * t287 ; let t290 = t289 * t285 ; let t291 = t290 * t287 ; let t292 = t291 * t290 ; let t293 = t292 . square () ; let t294 = t293 * t291 ; let t295 = t294 * t292 ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 * t294 ; let t299 = t298 * t295 ; let t300 = t299 . square () ; let t301 = t300 * t299 ; let t302 = t301 . square () ; let t303 = t301 . square () ; let t304 = t302 . square () ; let t305 = t304 * t299 ; let t306 = t305 * t298 ; let t307 = t306 * t299 ; let t308 = t307 * t306 ; let t309 = t308 . square () ; let t310 = t309 * t307 ; let t311 = t310 * t308 ; let t312 = t311 . square () ; let t313 = t312 * t310 ; let t314 = t313 . square () ; let t315 = t314 * t313 ; let t316 = t315 . square () ; let t317 = t316 * t313 ; let t318 = t317 * t311 ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 * t318 ; let t322 = t321 * t313 ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 . square () ; let t339 = t338 . square () ; let t340 = t339 . square () ; let t341 = t340 . square () ; let t342 = t341 . square () ; let t343 = t342 . square () ; let t344 = t343 . square () ; let t345 = t344 . square () ; let t346 = t345 . square () ; let t347 = t346 . square () ; let t348 = t347 . square () ; let t349 = t348 . square () ; let t350 = t349 . square () ; let t351 = t350 . square () ; let t352 = t351 . square () ; let t353 = t352 . square () ; let t354 = t353 . square () ; let t355 = t354 . square () ; let t356 = t355 . square () ; let t357 = t356 . square () ; let t358 = t357 . square () ; let t359 = t358 . square () ; let t360 = t359 . square () ; let t361 = t360 . square () ; let t362 = t361 . square () ; let t363 = t362 . square () ; let t364 = t363 . square () ; let t365 = t364 . square () ; let t366 = t365 . square () ; let t367 = t366 . square () ; let t368 = t367 . square () ; let t369 = t368 . square () ; let t370 = t369 . square () ; let t371 = t370 . square () ; let t372 = t371 . square () ; let t373 = t372 . square () ; let t374 = t373 . square () ; let t375 = t374 . square () ; let t376 = t375 . square () ; let t377 = t376 . square () ; let t378 = t377 . square () ; let t379 = t378 . square () ; let t380 = t379 . square () ; let t381 = t380 . square () ; let t382 = t381 . square () ; let t383 = t382 . square () ; let t384 = t383 . square () ; let t385 = t384 . square () ; let t386 = t385 . square () ; let t387 = t386 . square () ; let t388 = t387 . square () ; let t389 = t388 . square () ; let t390 = t389 . square () ; let t391 = t390 . square () ; let t392 = t391 . square () ; let t393 = t392 . square () ; let t394 = t393 . square () ; let t395 = t394 . square () ; let t396 = t395 . square () ; let t397 = t396 . square () ; let t398 = t397 . square () ; let t399 = t398 . square () ; let t400 = t399 . square () ; let t401 = t400 . square () ; let t402 = t401 . square () ; let t403 = t402 . square () ; let t404 = t403 . square () ; let t405 = t404 . square () ; let t406 = t405 . square () ; let t407 = t406 . square () ; let t408 = t407 . square () ; let t409 = t408 . square () ; let t410 = t409 . square () ; let t411 = t410 . square () ; let t412 = t411 . square () ; let t413 = t412 . square () ; let t414 = t413 . square () ; let t415 = t414 . square () ; let t416 = t415 . square () ; let t417 = t416 . square () ; let t418 = t417 . square () ; let t419 = t418 . square () ; let t420 = t419 . square () ; let t421 = t420 . square () ; let t422 = t421 . square () ; let t423 = t422 . square () ; let t424 = t423 . square () ; let t425 = t424 . square () ; let t426 = t425 . square () ; let t427 = t426 . square () ; let t428 = t427 . square () ; let t429 = t428 . square () ; let t430 = t429 . square () ; let t431 = t430 . square () ; let t432 = t431 . square () ; let t433 = t432 . square () ; let t434 = t433 . square () ; let t435 = t434 . square () ; let t436 = t435 . square () ; let t437 = t436 . square () ; let t438 = t437 . square () ; let t439 = t438 . square () ; let t440 = t439 . square () ; let t441 = t440 . square () ; let t442 = t441 . square () ; let t443 = t442 . square () ; let t444 = t443 . square () ; let t445 = t444 . square () ; let t446 = t445 . square () ; let t447 = t446 . square () ; let t448 = t447 . square () ; let t449 = t448 . square () ; let t450 = t449 . square () ; let t451 = t450 . square () ; let t452 = t451 . square () ; let t453 = t452 . square () ; let t454 = t453 . square () ; let t455 = t454 . square () ; let t456 = t455 . square () ; let t457 = t456 . square () ; let t458 = t457 . square () ; let t459 = t458 . square () ; let t460 = t459 . square () ; let t461 = t460 . square () ; let t462 = t461 . square () ; let t463 = t462 . square () ; let t464 = t463 . square () ; let t465 = t464 . square () ; let t466 = t465 . square () ; let t467 = t466 . square () ; let t468 = t467 . square () ; let t469 = t468 . square () ; let t470 = t469 . square () ; let t471 = t470 . square () ; let t472 = t471 . square () ; let t473 = t472 . square () ; let t474 = t473 . square () ; let t475 = t474 . square () ; let t476 = t475 . square () ; let t477 = t476 . square () ; let t478 = t477 . square () ; let t479 = t478 . square () ; let t480 = t479 . square () ; let t481 = t480 . square () ; let t482 = t481 . square () ; let t483 = t482 . square () ; let t484 = t483 . square () ; let t485 = t484 . square () ; let t486 = t485 . square () ; let t487 = t486 . square () ; let t488 = t487 . square () ; let t489 = t488 . square () ; let t490 = t489 . square () ; let t491 = t490 . square () ; let t492 = t491 . square () ; let t493 = t492 . square () ; let t494 = t493 . square () ; let t495 = t494 . square () ; let t496 = t495 . square () ; let t497 = t496 . square () ; let t498 = t497 . square () ; let t499 = t498 . square () ; let t500 = t499 . square () ; let t501 = t500 . square () ; let t502 = t501 . square () ; let t503 = t502 . square () ; let t504 = t503 . square () ; let t505 = t504 . square () ; let t506 = t505 . square () ; let t507 = t506 . square () ; let t508 = t507 . square () ; let t509 = t508 . square () ; let t510 = t509 . square () ; let t511 = t510 . square () ; let t512 = t511 . square () ; let t513 = t512 * t318 ; t513 } ; :: ff :: derive :: subtle :: CtOption :: new (sqrt , (sqrt * & sqrt) . ct_eq (self) ,) } } impl Internal { # [doc = r" Compares two elements in native representation. This is only used"] # [doc = r" internally."] # [inline (always)] fn cmp_native (& self , other : & Internal) -> :: core :: cmp :: Ordering { for (a , b) in self . 0 . iter () . rev () . zip (other . 0 . iter () . rev ()) { if a < b { return :: core :: cmp :: Ordering :: Less } else if a > b { return :: core :: cmp :: Ordering :: Greater } } :: core :: cmp :: Ordering :: Equal } # [doc = r" Determines if the element is really in the field. This is only used"] # [doc = r" internally."] # [inline (always)] fn is_valid (& self) -> bool { self . cmp_native (& MODULUS_LIMBS) == :: core :: cmp :: Ordering :: Less } # [inline (always)] fn add_nocarry (& mut self , other : & Internal) { let mut carry = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_carry) = :: ff :: derive :: adc (* a , * b , carry) ; * a = new_a ; carry = new_carry ; } } # [inline (always)] fn sub_noborrow (& mut self , other : & Internal) { let mut borrow = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_borrow) = :: ff :: derive :: sbb (* a , * b , borrow) ; * a = new_a ; borrow = new_borrow ; } } # [doc = r" Subtracts the modulus from this element if this element is not in the"] # [doc = r" field. Only used interally."] # [inline (always)] fn reduce (& mut self) { if ! self . is_valid () { self . sub_noborrow (& MODULUS_LIMBS) ; } } # [allow (clippy :: too_many_arguments)] # [inline (always)] fn mont_reduce (& mut self , r0 : u64 , mut r1 : u64 , mut r2 : u64 , mut r3 : u64 , mut r4 : u64 , mut r5 : u64 , mut r6 : u64 , mut r7 : u64 , mut r8 : u64 , mut r9 : u64 , mut r10 : u64 , mut r11 : u64 , mut r12 : u64 , mut r13 : u64) { let k = r0 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r0 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r1 , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r7 , carry2) = :: ff :: derive :: adc (r7 , 0 , carry) ; let k = r1 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r8 , carry2) = :: ff :: derive :: adc (r8 , carry2 , carry) ; let k = r2 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r9 , carry2) = :: ff :: derive :: adc (r9 , carry2 , carry) ; let k = r3 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r10 , carry2) = :: ff :: derive :: adc (r10 , carry2 , carry) ; let k = r4 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r11 , carry2) = :: ff :: derive :: adc (r11 , carry2 , carry) ; let k = r5 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r12 , carry2) = :: ff :: derive :: adc (r12 , carry2 , carry) ; let k = r6 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r12 , carry) = :: ff :: derive :: mac (r12 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r13 , carry2) = :: ff :: derive :: adc (r13 , carry2 , carry) ; self . 0 [0usize] = r7 ; self . 0 [1usize] = r8 ; self . 0 [2usize] = r9 ; self . 0 [3usize] = r10 ; self . 0 [4usize] = r11 ; self . 0 [5usize] = r12 ; self . 0 [6usize] = r13 ; self . reduce () ; } }#[cfg(test)] pub(super) const MODULUS_STRING: &str = "39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643";pub(super) const MODULUS_BYTES: &[u8] = &[115, 41, 197, 204, 106, 25, 236, 236, 122, 167, 176, 72, 178, 13, 26, 88, 223, 45, 55, 244, 129, 77, 99, 199, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255];#[cfg(test)] pub(super) const GENERATOR_STRING: &str = "19";