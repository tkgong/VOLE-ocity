# [repr (transparent)] pub struct Internal ([u64 ; 4usize]) ; type REPR_BYTES = [u8 ; 32usize] ; type REPR_BITS = REPR_BYTES ; # [doc = r" This is the modulus m of the prime field"] const MODULUS : REPR_BITS = [1u8 , 0u8 , 0u8 , 240u8 , 147u8 , 245u8 , 225u8 , 67u8 , 145u8 , 112u8 , 185u8 , 121u8 , 72u8 , 232u8 , 51u8 , 40u8 , 93u8 , 88u8 , 129u8 , 129u8 , 182u8 , 69u8 , 80u8 , 184u8 , 41u8 , 160u8 , 49u8 , 225u8 , 114u8 , 78u8 , 100u8 , 48u8 ,] ; # [doc = r" This is the modulus m of the prime field in limb form"] const MODULUS_LIMBS : Internal = Internal ([4891460686036598785u64 , 2896914383306846353u64 , 13281191951274694749u64 , 3486998266802970665u64 ,]) ; # [doc = r" The number of bits needed to represent the modulus."] const MODULUS_BITS : u32 = 254u32 ; # [doc = r" The number of bits that must be shaved from the beginning of"] # [doc = r" the representation when randomly sampling."] const REPR_SHAVE_BITS : u32 = 2u32 ; # [doc = r" 2^{limbs*64} mod m"] const R : Internal = Internal ([12436184717236109307u64 , 3962172157175319849u64 , 7381016538464732718u64 , 1011752739694698287u64 ,]) ; # [doc = r" 2^{limbs*64*2} mod m"] const R2 : Internal = Internal ([1997599621687373223u64 , 6052339484930628067u64 , 10108755138030829701u64 , 150537098327114917u64 ,]) ; # [doc = r" -(m^{-1} mod m) mod m"] const INV : u64 = 14042775128853446655u64 ; # [doc = r" Multiplicative generator of `MODULUS` - 1 order, also quadratic"] # [doc = r" nonresidue."] const GENERATOR : Internal = Internal ([1949230679015292902u64 , 16913946402569752895u64 , 5177146667339417225u64 , 1571765431670520771u64 ,]) ; # [doc = r" 2^s * t = MODULUS - 1 with t odd"] const S : u32 = 28u32 ; # [doc = r" 2^s root of unity computed by GENERATOR^t"] const ROOT_OF_UNITY : Internal = Internal ([7164790868263648668u64 , 11685701338293206998u64 , 6216421865291908056u64 , 1756667274303109607u64 ,]) ; # [derive (Copy , Clone)] pub struct InternalRepr (pub [u8 ; 32usize]) ; impl :: ff :: derive :: subtle :: ConstantTimeEq for InternalRepr { fn ct_eq (& self , other : & InternalRepr) -> :: ff :: derive :: subtle :: Choice { self . 0 . iter () . zip (other . 0 . iter ()) . map (| (a , b) | a . ct_eq (b)) . fold (1 . into () , | acc , x | acc & x) } } impl :: core :: cmp :: PartialEq for InternalRepr { fn eq (& self , other : & InternalRepr) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for InternalRepr { } impl :: core :: default :: Default for InternalRepr { fn default () -> InternalRepr { InternalRepr ([0u8 ; 32usize]) } } impl :: core :: fmt :: Debug for InternalRepr { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "0x") ? ; for i in self . 0 . iter () . rev () { write ! (f , "{:02x}" , * i) ? ; } Ok (()) } } impl AsRef < [u8] > for InternalRepr { # [inline (always)] fn as_ref (& self) -> & [u8] { & self . 0 } } impl AsMut < [u8] > for InternalRepr { # [inline (always)] fn as_mut (& mut self) -> & mut [u8] { & mut self . 0 } } impl :: core :: marker :: Copy for Internal { } impl :: core :: clone :: Clone for Internal { fn clone (& self) -> Internal { * self } } impl :: core :: default :: Default for Internal { fn default () -> Internal { use :: ff :: Field ; Internal :: zero () } } impl :: ff :: derive :: subtle :: ConstantTimeEq for Internal { fn ct_eq (& self , other : & Internal) -> :: ff :: derive :: subtle :: Choice { use :: ff :: PrimeField ; self . to_repr () . ct_eq (& other . to_repr ()) } } impl :: core :: cmp :: PartialEq for Internal { fn eq (& self , other : & Internal) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for Internal { } impl :: core :: fmt :: Debug for Internal { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use :: ff :: PrimeField ; write ! (f , "{}({:?})" , stringify ! (Internal) , self . to_repr ()) } } # [doc = r" Elements are ordered lexicographically."] impl Ord for Internal { # [inline (always)] fn cmp (& self , other : & Internal) -> :: core :: cmp :: Ordering { let mut a = * self ; a . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , 0 , 0 , 0 , 0) ; let mut b = * other ; b . mont_reduce (other . 0 [0usize] , other . 0 [1usize] , other . 0 [2usize] , other . 0 [3usize] , 0 , 0 , 0 , 0) ; a . cmp_native (& b) } } impl PartialOrd for Internal { # [inline (always)] fn partial_cmp (& self , other : & Internal) -> Option < :: core :: cmp :: Ordering > { Some (self . cmp (other)) } } impl From < u64 > for Internal { # [inline (always)] fn from (val : u64) -> Internal { let mut raw = [0u64 ; 4usize] ; raw [0] = val ; Internal (raw) * R2 } } impl From < Internal > for InternalRepr { fn from (e : Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl < 'a > From < & 'a Internal > for InternalRepr { fn from (e : & 'a Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl :: ff :: derive :: subtle :: ConditionallySelectable for Internal { fn conditional_select (a : & Internal , b : & Internal , choice : :: ff :: derive :: subtle :: Choice) -> Internal { let mut res = [0u64 ; 4usize] ; for i in 0 .. 4usize { res [i] = u64 :: conditional_select (& a . 0 [i] , & b . 0 [i] , choice) ; } Internal (res) } } impl :: core :: ops :: Neg for Internal { type Output = Internal ; # [inline] fn neg (self) -> Internal { use :: ff :: Field ; let mut ret = self ; if ! ret . is_zero_vartime () { let mut tmp = MODULUS_LIMBS ; tmp . sub_noborrow (& ret) ; ret = tmp ; } ret } } impl < 'r > :: core :: ops :: Add < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn add (self , other : & Internal) -> Internal { use :: core :: ops :: AddAssign ; let mut ret = self ; ret . add_assign (other) ; ret } } impl :: core :: ops :: Add for Internal { type Output = Internal ; # [inline] fn add (self , other : Internal) -> Self { self + & other } } impl < 'r > :: core :: ops :: AddAssign < & 'r Internal > for Internal { # [inline] fn add_assign (& mut self , other : & Internal) { self . add_nocarry (other) ; self . reduce () ; } } impl :: core :: ops :: AddAssign for Internal { # [inline] fn add_assign (& mut self , other : Internal) { self . add_assign (& other) ; } } impl < 'r > :: core :: ops :: Sub < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn sub (self , other : & Internal) -> Self { use :: core :: ops :: SubAssign ; let mut ret = self ; ret . sub_assign (other) ; ret } } impl :: core :: ops :: Sub for Internal { type Output = Internal ; # [inline] fn sub (self , other : Internal) -> Self { self - & other } } impl < 'r > :: core :: ops :: SubAssign < & 'r Internal > for Internal { # [inline] fn sub_assign (& mut self , other : & Internal) { if other . cmp_native (self) == :: core :: cmp :: Ordering :: Greater { self . add_nocarry (& MODULUS_LIMBS) ; } self . sub_noborrow (other) ; } } impl :: core :: ops :: SubAssign for Internal { # [inline] fn sub_assign (& mut self , other : Internal) { self . sub_assign (& other) ; } } impl < 'r > :: core :: ops :: Mul < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn mul (self , other : & Internal) -> Self { use :: core :: ops :: MulAssign ; let mut ret = self ; ret . mul_assign (other) ; ret } } impl :: core :: ops :: Mul for Internal { type Output = Internal ; # [inline] fn mul (self , other : Internal) -> Self { self * & other } } impl < 'r > :: core :: ops :: MulAssign < & 'r Internal > for Internal { # [inline] fn mul_assign (& mut self , other : & Internal) { let carry = 0 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [0usize] , carry) ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [3usize] , carry) ; let r4 = carry ; let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (r1 , self . 0 [1usize] , other . 0 [0usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , other . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , other . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , other . 0 [3usize] , carry) ; let r5 = carry ; let carry = 0 ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [2usize] , other . 0 [0usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [2usize] , other . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , other . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , other . 0 [3usize] , carry) ; let r6 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [3usize] , other . 0 [0usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [3usize] , other . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [3usize] , other . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , other . 0 [3usize] , carry) ; let r7 = carry ; self . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7) ; } } impl :: core :: ops :: MulAssign for Internal { # [inline] fn mul_assign (& mut self , other : Internal) { self . mul_assign (& other) ; } } impl :: ff :: PrimeField for Internal { type Repr = InternalRepr ; fn from_repr (r : InternalRepr) -> :: ff :: derive :: subtle :: CtOption < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 4usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; let borrow = r . 0 . iter () . zip (MODULUS_LIMBS . 0 . iter ()) . fold (0 , | borrow , (a , b) | { :: ff :: derive :: sbb (* a , * b , borrow) . 1 }) ; let is_some = :: ff :: derive :: subtle :: Choice :: from ((borrow as u8) & 1) ; :: ff :: derive :: subtle :: CtOption :: new (r * & R2 , is_some) } fn from_repr_vartime (r : InternalRepr) -> Option < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 4usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; if r . is_valid () { Some (r * R2) } else { None } } fn to_repr (& self) -> InternalRepr { use :: ff :: derive :: byteorder :: ByteOrder ; let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , 0 , 0 , 0 , 0) ; let mut repr = [0u8 ; 32usize] ; :: ff :: derive :: byteorder :: LittleEndian :: write_u64_into (& r . 0 , & mut repr [..]) ; InternalRepr (repr) } # [inline (always)] fn is_odd (& self) -> :: ff :: derive :: subtle :: Choice { let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , 0 , 0 , 0 , 0) ; :: ff :: derive :: subtle :: Choice :: from ((r . 0 [0] & 1) as u8) } const NUM_BITS : u32 = MODULUS_BITS ; const CAPACITY : u32 = Self :: NUM_BITS - 1 ; fn multiplicative_generator () -> Self { GENERATOR } const MULTIPLICATIVE_GENERATOR : Self = GENERATOR ; const S : u32 = S ; fn root_of_unity () -> Self { ROOT_OF_UNITY } } impl :: ff :: Field for Internal { # [doc = r" Computes a uniformly random element using rejection sampling."] fn random (mut rng : impl :: ff :: derive :: rand_core :: RngCore) -> Self { loop { let mut tmp = { let mut repr = [0u64 ; 4usize] ; for i in 0 .. 4usize { repr [i] = rng . next_u64 () ; } Internal (repr) } ; tmp . 0 . as_mut () [3usize] &= 0xffffffffffffffffu64 . checked_shr (REPR_SHAVE_BITS) . unwrap_or (0) ; if tmp . is_valid () { return tmp } } } # [inline] fn zero () -> Self { Internal ([0 ; 4usize]) } const ZERO : Self = Internal ([0 ; 4usize]) ; # [inline] fn one () -> Self { R } const ONE : Self = R ; # [inline] fn is_zero (& self) -> :: ff :: derive :: subtle :: Choice { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (& Self :: zero ()) } # [inline] fn is_zero_vartime (& self) -> bool { self . 0 . iter () . all (| & e | e == 0) } # [inline] fn double (& self) -> Self { let mut ret = * self ; let mut last = 0 ; for i in & mut ret . 0 { let tmp = * i >> 63 ; * i <<= 1 ; * i |= last ; last = tmp ; } ret . reduce () ; ret } fn invert (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let inv = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 . square () ; let t3 = t2 . square () ; let t4 = t3 . square () ; let t5 = t4 . square () ; let t6 = t5 * t0 ; let t7 = t6 . square () ; let t8 = t7 * t6 ; let t9 = t8 . square () ; let t10 = t8 . square () ; let t11 = t9 . square () ; let t12 = t11 * t6 ; let t13 = t12 * t1 ; let t14 = t13 . square () ; let t15 = t14 . square () ; let t16 = t14 . square () ; let t17 = t15 . square () ; let t18 = t17 . square () ; let t19 = t18 * t14 ; let t20 = t19 * t6 ; let t21 = t20 . square () ; let t22 = t21 . square () ; let t23 = t22 * t13 ; let t24 = t23 * t20 ; let t25 = t24 * t23 ; let t26 = t25 . square () ; let t27 = t26 . square () ; let t28 = t27 . square () ; let t29 = t28 * t24 ; let t30 = t29 * t25 ; let t31 = t30 * t29 ; let t32 = t31 . square () ; let t33 = t32 * t30 ; let t34 = t33 * t31 ; let t35 = t34 . square () ; let t36 = t35 * t34 ; let t37 = t36 . square () ; let t38 = t36 . square () ; let t39 = t37 * t33 ; let t40 = t39 . square () ; let t41 = t40 * t34 ; let t42 = t41 * t39 ; let t43 = t42 . square () ; let t44 = t43 * t41 ; let t45 = t44 . square () ; let t46 = t45 * t42 ; let t47 = t46 . square () ; let t48 = t47 * t46 ; let t49 = t48 . square () ; let t50 = t49 * t46 ; let t51 = t50 . square () ; let t52 = t51 * t46 ; let t53 = t52 * t44 ; let t54 = t53 . square () ; let t55 = t54 * t53 ; let t56 = t55 . square () ; let t57 = t56 * t53 ; let t58 = t57 * t46 ; let t59 = t58 * t53 ; let t60 = t59 * t58 ; let t61 = t60 . square () ; let t62 = t61 . square () ; let t63 = t62 * t60 ; let t64 = t63 * t59 ; let t65 = t64 * t60 ; let t66 = t65 . square () ; let t67 = t66 * t65 ; let t68 = t67 * t64 ; let t69 = t68 * t65 ; let t70 = t69 . square () ; let t71 = t70 . square () ; let t72 = t71 * t69 ; let t73 = t72 * t68 ; let t74 = t73 . square () ; let t75 = t74 * t69 ; let t76 = t75 * t73 ; let t77 = t76 * t75 ; let t78 = t77 . square () ; let t79 = t78 * t76 ; let t80 = t79 . square () ; let t81 = t80 . square () ; let t82 = t81 * t79 ; let t83 = t82 * t77 ; let t84 = t83 . square () ; let t85 = t84 * t79 ; let t86 = t85 . square () ; let t87 = t86 . square () ; let t88 = t87 * t83 ; let t89 = t88 . square () ; let t90 = t89 * t88 ; let t91 = t90 . square () ; let t92 = t90 . square () ; let t93 = t91 * t85 ; let t94 = t93 * t88 ; let t95 = t94 . square () ; let t96 = t95 * t93 ; let t97 = t96 . square () ; let t98 = t97 * t94 ; let t99 = t98 * t96 ; let t100 = t99 . square () ; let t101 = t100 . square () ; let t102 = t101 . square () ; let t103 = t102 * t98 ; let t104 = t103 * t99 ; let t105 = t104 . square () ; let t106 = t105 * t104 ; let t107 = t106 . square () ; let t108 = t106 . square () ; let t109 = t107 * t103 ; let t110 = t109 . square () ; let t111 = t110 . square () ; let t112 = t111 * t109 ; let t113 = t112 . square () ; let t114 = t113 . square () ; let t115 = t114 * t110 ; let t116 = t115 * t104 ; let t117 = t116 * t109 ; let t118 = t117 * t116 ; let t119 = t118 * t117 ; let t120 = t119 * t118 ; let t121 = t120 * t119 ; let t122 = t121 . square () ; let t123 = t122 * t121 ; let t124 = t123 . square () ; let t125 = t123 . square () ; let t126 = t124 * t120 ; let t127 = t126 . square () ; let t128 = t127 * t126 ; let t129 = t128 . square () ; let t130 = t128 . square () ; let t131 = t129 . square () ; let t132 = t131 * t126 ; let t133 = t132 * t121 ; let t134 = t133 * t126 ; let t135 = t134 . square () ; let t136 = t135 * t134 ; let t137 = t136 . square () ; let t138 = t136 . square () ; let t139 = t137 * t133 ; let t140 = t139 * t134 ; let t141 = t140 . square () ; let t142 = t141 . square () ; let t143 = t142 * t139 ; let t144 = t143 . square () ; let t145 = t144 * t143 ; let t146 = t145 * t140 ; let t147 = t146 * t143 ; let t148 = t147 . square () ; let t149 = t148 * t147 ; let t150 = t149 * t146 ; let t151 = t150 * t147 ; let t152 = t151 . square () ; let t153 = t152 . square () ; let t154 = t153 . square () ; let t155 = t154 * t151 ; let t156 = t155 * t150 ; let t157 = t156 * t151 ; let t158 = t157 . square () ; let t159 = t158 * t157 ; let t160 = t159 . square () ; let t161 = t159 . square () ; let t162 = t160 * t156 ; let t163 = t162 * t157 ; let t164 = t163 . square () ; let t165 = t164 * t162 ; let t166 = t165 . square () ; let t167 = t166 . square () ; let t168 = t167 * t165 ; let t169 = t168 . square () ; let t170 = t169 * t168 ; let t171 = t170 * t165 ; let t172 = t171 . square () ; let t173 = t172 . square () ; let t174 = t173 . square () ; let t175 = t174 * t168 ; let t176 = t175 * t163 ; let t177 = t176 * t165 ; let t178 = t177 . square () ; let t179 = t178 * t177 ; let t180 = t179 . square () ; let t181 = t179 . square () ; let t182 = t180 . square () ; let t183 = t182 * t177 ; let t184 = t183 * t176 ; let t185 = t184 . square () ; let t186 = t185 * t184 ; let t187 = t186 . square () ; let t188 = t186 . square () ; let t189 = t187 . square () ; let t190 = t189 * t184 ; let t191 = t190 . square () ; let t192 = t191 . square () ; let t193 = t191 . square () ; let t194 = t192 * t177 ; let t195 = t194 * t184 ; let t196 = t195 * t194 ; let t197 = t196 . square () ; let t198 = t197 . square () ; let t199 = t198 . square () ; let t200 = t198 . square () ; let t201 = t199 . square () ; let t202 = t201 . square () ; let t203 = t202 * t197 ; let t204 = t203 * t195 ; let t205 = t204 * t196 ; let t206 = t205 * t204 ; let t207 = t206 . square () ; let t208 = t207 * t205 ; let t209 = t208 . square () ; let t210 = t209 . square () ; let t211 = t210 * t206 ; let t212 = t211 * t208 ; let t213 = t212 . square () ; let t214 = t213 . square () ; let t215 = t214 * t211 ; let t216 = t215 . square () ; let t217 = t216 . square () ; let t218 = t217 . square () ; let t219 = t218 . square () ; let t220 = t219 . square () ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 . square () ; let t228 = t227 . square () ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 . square () ; let t234 = t233 . square () ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 . square () ; let t240 = t239 . square () ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 . square () ; let t245 = t244 . square () ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 . square () ; let t249 = t248 . square () ; let t250 = t249 . square () ; let t251 = t250 . square () ; let t252 = t251 . square () ; let t253 = t252 . square () ; let t254 = t253 . square () ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 . square () ; let t258 = t257 . square () ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 . square () ; let t262 = t261 . square () ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 . square () ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 . square () ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 . square () ; let t272 = t271 . square () ; let t273 = t272 . square () ; let t274 = t273 . square () ; let t275 = t274 . square () ; let t276 = t275 . square () ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 . square () ; let t281 = t280 . square () ; let t282 = t281 . square () ; let t283 = t282 . square () ; let t284 = t283 . square () ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 . square () ; let t289 = t288 . square () ; let t290 = t289 . square () ; let t291 = t290 . square () ; let t292 = t291 . square () ; let t293 = t292 . square () ; let t294 = t293 . square () ; let t295 = t294 . square () ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 . square () ; let t299 = t298 . square () ; let t300 = t299 . square () ; let t301 = t300 . square () ; let t302 = t301 . square () ; let t303 = t302 . square () ; let t304 = t303 . square () ; let t305 = t304 . square () ; let t306 = t305 . square () ; let t307 = t306 . square () ; let t308 = t307 . square () ; let t309 = t308 . square () ; let t310 = t309 . square () ; let t311 = t310 . square () ; let t312 = t311 . square () ; let t313 = t312 . square () ; let t314 = t313 . square () ; let t315 = t314 . square () ; let t316 = t315 . square () ; let t317 = t316 . square () ; let t318 = t317 . square () ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 . square () ; let t322 = t321 . square () ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 . square () ; let t339 = t338 . square () ; let t340 = t339 . square () ; let t341 = t340 . square () ; let t342 = t341 * t212 ; t342 } ; :: ff :: derive :: subtle :: CtOption :: new (inv , ! self . ct_eq (& Internal :: zero ())) } # [inline] fn square (& self) -> Self { let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [3usize] , carry) ; let r4 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , self . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , self . 0 [3usize] , carry) ; let r5 = carry ; let carry = 0 ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , self . 0 [3usize] , carry) ; let r6 = carry ; let r7 = r6 >> 63 ; let r6 = (r6 << 1) | (r5 >> 63) ; let r5 = (r5 << 1) | (r4 >> 63) ; let r4 = (r4 << 1) | (r3 >> 63) ; let r3 = (r3 << 1) | (r2 >> 63) ; let r2 = (r2 << 1) | (r1 >> 63) ; let r1 = r1 << 1 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [0usize] , 0) ; let (r1 , carry) = :: ff :: derive :: adc (r1 , 0 , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , self . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: adc (r3 , 0 , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , self . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: adc (r5 , 0 , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , self . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: adc (r7 , 0 , carry) ; let mut ret = * self ; ret . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7) ; ret } fn sqrt (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: { ConditionallySelectable , ConstantTimeEq } ; let w = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 * t0 ; let t3 = t2 . square () ; let t4 = t3 . square () ; let t5 = t4 . square () ; let t6 = t5 * t4 ; let t7 = t5 * t4 ; let t8 = t6 . square () ; let t9 = t8 . square () ; let t10 = t9 . square () ; let t11 = t10 * t4 ; let t12 = t11 * t0 ; let t13 = t12 * t2 ; let t14 = t13 . square () ; let t15 = t14 * t13 ; let t16 = t15 . square () ; let t17 = t16 * t13 ; let t18 = t17 * t12 ; let t19 = t18 * t13 ; let t20 = t19 . square () ; let t21 = t20 . square () ; let t22 = t21 * t20 ; let t23 = t22 . square () ; let t24 = t23 * t20 ; let t25 = t23 * t20 ; let t26 = t24 . square () ; let t27 = t26 . square () ; let t28 = t27 * t20 ; let t29 = t28 * t18 ; let t30 = t29 * t19 ; let t31 = t30 . square () ; let t32 = t31 . square () ; let t33 = t32 * t30 ; let t34 = t33 * t29 ; let t35 = t34 . square () ; let t36 = t35 * t34 ; let t37 = t36 . square () ; let t38 = t36 . square () ; let t39 = t37 . square () ; let t40 = t39 . square () ; let t41 = t39 . square () ; let t42 = t40 * t30 ; let t43 = t42 . square () ; let t44 = t43 * t42 ; let t45 = t44 . square () ; let t46 = t44 . square () ; let t47 = t45 . square () ; let t48 = t47 * t42 ; let t49 = t48 . square () ; let t50 = t49 . square () ; let t51 = t50 * t42 ; let t52 = t51 * t34 ; let t53 = t52 * t42 ; let t54 = t53 * t52 ; let t55 = t54 * t53 ; let t56 = t55 * t54 ; let t57 = t56 . square () ; let t58 = t57 * t56 ; let t59 = t58 * t55 ; let t60 = t59 . square () ; let t61 = t60 * t56 ; let t62 = t61 . square () ; let t63 = t62 * t61 ; let t64 = t63 . square () ; let t65 = t64 * t61 ; let t66 = t65 * t59 ; let t67 = t66 . square () ; let t68 = t67 * t61 ; let t69 = t68 * t66 ; let t70 = t69 . square () ; let t71 = t70 * t68 ; let t72 = t71 . square () ; let t73 = t72 * t71 ; let t74 = t73 * t69 ; let t75 = t74 . square () ; let t76 = t75 * t71 ; let t77 = t76 * t74 ; let t78 = t77 . square () ; let t79 = t78 . square () ; let t80 = t79 * t76 ; let t81 = t80 * t77 ; let t82 = t81 * t80 ; let t83 = t82 * t81 ; let t84 = t83 . square () ; let t85 = t84 * t83 ; let t86 = t85 * t82 ; let t87 = t86 . square () ; let t88 = t87 * t86 ; let t89 = t88 * t83 ; let t90 = t89 . square () ; let t91 = t90 * t86 ; let t92 = t91 . square () ; let t93 = t92 * t89 ; let t94 = t93 * t91 ; let t95 = t94 * t93 ; let t96 = t95 * t94 ; let t97 = t96 * t95 ; let t98 = t97 * t96 ; let t99 = t98 . square () ; let t100 = t99 * t98 ; let t101 = t100 * t97 ; let t102 = t101 * t98 ; let t103 = t102 * t101 ; let t104 = t103 . square () ; let t105 = t104 * t102 ; let t106 = t105 . square () ; let t107 = t106 * t103 ; let t108 = t107 . square () ; let t109 = t108 * t107 ; let t110 = t109 * t105 ; let t111 = t110 * t107 ; let t112 = t111 * t110 ; let t113 = t112 * t111 ; let t114 = t113 . square () ; let t115 = t114 * t113 ; let t116 = t115 . square () ; let t117 = t116 * t113 ; let t118 = t117 . square () ; let t119 = t118 * t113 ; let t120 = t119 * t112 ; let t121 = t120 . square () ; let t122 = t121 * t120 ; let t123 = t122 * t121 ; let t124 = t123 . square () ; let t125 = t124 . square () ; let t126 = t125 * t123 ; let t127 = t126 * t122 ; let t128 = t127 . square () ; let t129 = t128 . square () ; let t130 = t129 . square () ; let t131 = t130 * t123 ; let t132 = t131 * t113 ; let t133 = t132 * t120 ; let t134 = t133 * t132 ; let t135 = t134 . square () ; let t136 = t135 * t134 ; let t137 = t136 * t133 ; let t138 = t137 . square () ; let t139 = t138 . square () ; let t140 = t139 * t134 ; let t141 = t140 . square () ; let t142 = t141 * t137 ; let t143 = t142 * t140 ; let t144 = t143 * t142 ; let t145 = t144 . square () ; let t146 = t145 . square () ; let t147 = t146 * t144 ; let t148 = t147 * t143 ; let t149 = t148 . square () ; let t150 = t149 * t144 ; let t151 = t150 . square () ; let t152 = t151 . square () ; let t153 = t152 * t150 ; let t154 = t153 * t148 ; let t155 = t154 . square () ; let t156 = t155 * t150 ; let t157 = t156 . square () ; let t158 = t157 * t154 ; let t159 = t158 . square () ; let t160 = t159 * t156 ; let t161 = t160 * t158 ; let t162 = t161 . square () ; let t163 = t162 . square () ; let t164 = t163 * t161 ; let t165 = t164 . square () ; let t166 = t164 . square () ; let t167 = t165 * t160 ; let t168 = t167 * t161 ; let t169 = t168 . square () ; let t170 = t169 * t168 ; let t171 = t170 . square () ; let t172 = t170 . square () ; let t173 = t171 . square () ; let t174 = t171 . square () ; let t175 = t173 * t167 ; let t176 = t175 * t168 ; let t177 = t176 * t175 ; let t178 = t177 . square () ; let t179 = t178 * t177 ; let t180 = t179 . square () ; let t181 = t180 * t177 ; let t182 = t180 * t178 ; let t183 = t182 . square () ; let t184 = t183 . square () ; let t185 = t184 . square () ; let t186 = t185 * t181 ; let t187 = t186 * t176 ; let t188 = t187 * t177 ; let t189 = t188 * t187 ; let t190 = t189 . square () ; let t191 = t190 . square () ; let t192 = t191 . square () ; let t193 = t192 . square () ; let t194 = t193 . square () ; let t195 = t194 . square () ; let t196 = t195 . square () ; let t197 = t196 . square () ; let t198 = t197 . square () ; let t199 = t198 . square () ; let t200 = t199 . square () ; let t201 = t200 . square () ; let t202 = t201 . square () ; let t203 = t202 . square () ; let t204 = t203 . square () ; let t205 = t204 . square () ; let t206 = t205 . square () ; let t207 = t206 . square () ; let t208 = t207 . square () ; let t209 = t208 . square () ; let t210 = t209 . square () ; let t211 = t210 . square () ; let t212 = t211 . square () ; let t213 = t212 . square () ; let t214 = t213 . square () ; let t215 = t214 . square () ; let t216 = t215 . square () ; let t217 = t216 . square () ; let t218 = t217 . square () ; let t219 = t218 . square () ; let t220 = t219 . square () ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 . square () ; let t228 = t227 . square () ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 . square () ; let t234 = t233 . square () ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 . square () ; let t240 = t239 . square () ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 . square () ; let t245 = t244 . square () ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 . square () ; let t249 = t248 . square () ; let t250 = t249 . square () ; let t251 = t250 . square () ; let t252 = t251 . square () ; let t253 = t252 . square () ; let t254 = t253 . square () ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 . square () ; let t258 = t257 . square () ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 . square () ; let t262 = t261 . square () ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 . square () ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 . square () ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 . square () ; let t272 = t271 . square () ; let t273 = t272 . square () ; let t274 = t273 . square () ; let t275 = t274 . square () ; let t276 = t275 . square () ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 . square () ; let t281 = t280 . square () ; let t282 = t281 . square () ; let t283 = t282 . square () ; let t284 = t283 . square () ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 . square () ; let t289 = t288 . square () ; let t290 = t289 . square () ; let t291 = t290 . square () ; let t292 = t291 . square () ; let t293 = t292 . square () ; let t294 = t293 . square () ; let t295 = t294 . square () ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 . square () ; let t299 = t298 . square () ; let t300 = t299 . square () ; let t301 = t300 . square () ; let t302 = t301 * t188 ; t302 } ; let mut v = S ; let mut x = * self * & w ; let mut b = x * & w ; let mut z = ROOT_OF_UNITY ; for max_v in (1 ..= S) . rev () { let mut k = 1 ; let mut tmp = b . square () ; let mut j_less_than_v : :: ff :: derive :: subtle :: Choice = 1 . into () ; for j in 2 .. max_v { let tmp_is_one = tmp . ct_eq (& Internal :: one ()) ; let squared = Internal :: conditional_select (& tmp , & z , tmp_is_one) . square () ; tmp = Internal :: conditional_select (& squared , & tmp , tmp_is_one) ; let new_z = Internal :: conditional_select (& z , & squared , tmp_is_one) ; j_less_than_v &= ! j . ct_eq (& v) ; k = u32 :: conditional_select (& j , & k , tmp_is_one) ; z = Internal :: conditional_select (& z , & new_z , j_less_than_v) ; } let result = x * & z ; x = Internal :: conditional_select (& result , & x , b . ct_eq (& Internal :: one ())) ; z = z . square () ; b *= & z ; v = k ; } :: ff :: derive :: subtle :: CtOption :: new (x , (x * & x) . ct_eq (self) ,) } } impl Internal { # [doc = r" Compares two elements in native representation. This is only used"] # [doc = r" internally."] # [inline (always)] fn cmp_native (& self , other : & Internal) -> :: core :: cmp :: Ordering { for (a , b) in self . 0 . iter () . rev () . zip (other . 0 . iter () . rev ()) { if a < b { return :: core :: cmp :: Ordering :: Less } else if a > b { return :: core :: cmp :: Ordering :: Greater } } :: core :: cmp :: Ordering :: Equal } # [doc = r" Determines if the element is really in the field. This is only used"] # [doc = r" internally."] # [inline (always)] fn is_valid (& self) -> bool { self . cmp_native (& MODULUS_LIMBS) == :: core :: cmp :: Ordering :: Less } # [inline (always)] fn add_nocarry (& mut self , other : & Internal) { let mut carry = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_carry) = :: ff :: derive :: adc (* a , * b , carry) ; * a = new_a ; carry = new_carry ; } } # [inline (always)] fn sub_noborrow (& mut self , other : & Internal) { let mut borrow = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_borrow) = :: ff :: derive :: sbb (* a , * b , borrow) ; * a = new_a ; borrow = new_borrow ; } } # [doc = r" Subtracts the modulus from this element if this element is not in the"] # [doc = r" field. Only used interally."] # [inline (always)] fn reduce (& mut self) { if ! self . is_valid () { self . sub_noborrow (& MODULUS_LIMBS) ; } } # [allow (clippy :: too_many_arguments)] # [inline (always)] fn mont_reduce (& mut self , r0 : u64 , mut r1 : u64 , mut r2 : u64 , mut r3 : u64 , mut r4 : u64 , mut r5 : u64 , mut r6 : u64 , mut r7 : u64) { let k = r0 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r0 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r1 , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r4 , carry2) = :: ff :: derive :: adc (r4 , 0 , carry) ; let k = r1 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r5 , carry2) = :: ff :: derive :: adc (r5 , carry2 , carry) ; let k = r2 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r6 , carry2) = :: ff :: derive :: adc (r6 , carry2 , carry) ; let k = r3 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r7 , carry2) = :: ff :: derive :: adc (r7 , carry2 , carry) ; self . 0 [0usize] = r4 ; self . 0 [1usize] = r5 ; self . 0 [2usize] = r6 ; self . 0 [3usize] = r7 ; self . reduce () ; } }#[cfg(test)] pub(super) const MODULUS_STRING: &str = "21888242871839275222246405745257275088548364400416034343698204186575808495617";pub(super) const MODULUS_BYTES: &[u8] = &[1, 0, 0, 240, 147, 245, 225, 67, 145, 112, 185, 121, 72, 232, 51, 40, 93, 88, 129, 129, 182, 69, 80, 184, 41, 160, 49, 225, 114, 78, 100, 48];#[cfg(test)] pub(super) const GENERATOR_STRING: &str = "5";