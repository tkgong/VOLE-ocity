# [repr (transparent)] pub struct Internal ([u64 ; 7usize]) ; type REPR_BYTES = [u8 ; 56usize] ; type REPR_BITS = REPR_BYTES ; # [doc = r" This is the modulus m of the prime field"] const MODULUS : REPR_BITS = [175u8 , 253u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 255u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 , 0u8 ,] ; # [doc = r" This is the modulus m of the prime field in limb form"] const MODULUS_LIMBS : Internal = Internal ([18446744073709551023u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 65535u64 ,]) ; # [doc = r" The number of bits needed to represent the modulus."] const MODULUS_BITS : u32 = 400u32 ; # [doc = r" The number of bits that must be shaved from the beginning of"] # [doc = r" the representation when randomly sampling."] const REPR_SHAVE_BITS : u32 = 48u32 ; # [doc = r" 2^{limbs*64} mod m"] const R : Internal = Internal ([166914661189419008u64 , 0u64 , 0u64 , 0u64 , 0u64 , 0u64 , 0u64 ,]) ; # [doc = r" 2^{limbs*64*2} mod m"] const R2 : Internal = Internal ([0u64 , 1510320954671104u64 , 0u64 , 0u64 , 0u64 , 0u64 , 0u64 ,]) ; # [doc = r" -(m^{-1} mod m) mod m"] const INV : u64 = 13407330009728190129u64 ; # [doc = r" Multiplicative generator of `MODULUS` - 1 order, also quadratic"] # [doc = r" nonresidue."] const GENERATOR : Internal = Internal ([834573305947095040u64 , 0u64 , 0u64 , 0u64 , 0u64 , 0u64 , 0u64 ,]) ; # [doc = r" 2^s * t = MODULUS - 1 with t odd"] const S : u32 = 1u32 ; # [doc = r" 2^s root of unity computed by GENERATOR^t"] const ROOT_OF_UNITY : Internal = Internal ([18279829412520132015u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 18446744073709551615u64 , 65535u64 ,]) ; # [derive (Copy , Clone)] pub struct InternalRepr (pub [u8 ; 56usize]) ; impl :: ff :: derive :: subtle :: ConstantTimeEq for InternalRepr { fn ct_eq (& self , other : & InternalRepr) -> :: ff :: derive :: subtle :: Choice { self . 0 . iter () . zip (other . 0 . iter ()) . map (| (a , b) | a . ct_eq (b)) . fold (1 . into () , | acc , x | acc & x) } } impl :: core :: cmp :: PartialEq for InternalRepr { fn eq (& self , other : & InternalRepr) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for InternalRepr { } impl :: core :: default :: Default for InternalRepr { fn default () -> InternalRepr { InternalRepr ([0u8 ; 56usize]) } } impl :: core :: fmt :: Debug for InternalRepr { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "0x") ? ; for i in self . 0 . iter () . rev () { write ! (f , "{:02x}" , * i) ? ; } Ok (()) } } impl AsRef < [u8] > for InternalRepr { # [inline (always)] fn as_ref (& self) -> & [u8] { & self . 0 } } impl AsMut < [u8] > for InternalRepr { # [inline (always)] fn as_mut (& mut self) -> & mut [u8] { & mut self . 0 } } impl :: core :: marker :: Copy for Internal { } impl :: core :: clone :: Clone for Internal { fn clone (& self) -> Internal { * self } } impl :: core :: default :: Default for Internal { fn default () -> Internal { use :: ff :: Field ; Internal :: zero () } } impl :: ff :: derive :: subtle :: ConstantTimeEq for Internal { fn ct_eq (& self , other : & Internal) -> :: ff :: derive :: subtle :: Choice { use :: ff :: PrimeField ; self . to_repr () . ct_eq (& other . to_repr ()) } } impl :: core :: cmp :: PartialEq for Internal { fn eq (& self , other : & Internal) -> bool { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (other) . into () } } impl :: core :: cmp :: Eq for Internal { } impl :: core :: fmt :: Debug for Internal { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use :: ff :: PrimeField ; write ! (f , "{}({:?})" , stringify ! (Internal) , self . to_repr ()) } } # [doc = r" Elements are ordered lexicographically."] impl Ord for Internal { # [inline (always)] fn cmp (& self , other : & Internal) -> :: core :: cmp :: Ordering { let mut a = * self ; a . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , self . 0 [5usize] , self . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; let mut b = * other ; b . mont_reduce (other . 0 [0usize] , other . 0 [1usize] , other . 0 [2usize] , other . 0 [3usize] , other . 0 [4usize] , other . 0 [5usize] , other . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; a . cmp_native (& b) } } impl PartialOrd for Internal { # [inline (always)] fn partial_cmp (& self , other : & Internal) -> Option < :: core :: cmp :: Ordering > { Some (self . cmp (other)) } } impl From < u64 > for Internal { # [inline (always)] fn from (val : u64) -> Internal { let mut raw = [0u64 ; 7usize] ; raw [0] = val ; Internal (raw) * R2 } } impl From < Internal > for InternalRepr { fn from (e : Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl < 'a > From < & 'a Internal > for InternalRepr { fn from (e : & 'a Internal) -> InternalRepr { use :: ff :: PrimeField ; e . to_repr () } } impl :: ff :: derive :: subtle :: ConditionallySelectable for Internal { fn conditional_select (a : & Internal , b : & Internal , choice : :: ff :: derive :: subtle :: Choice) -> Internal { let mut res = [0u64 ; 7usize] ; for i in 0 .. 7usize { res [i] = u64 :: conditional_select (& a . 0 [i] , & b . 0 [i] , choice) ; } Internal (res) } } impl :: core :: ops :: Neg for Internal { type Output = Internal ; # [inline] fn neg (self) -> Internal { use :: ff :: Field ; let mut ret = self ; if ! ret . is_zero_vartime () { let mut tmp = MODULUS_LIMBS ; tmp . sub_noborrow (& ret) ; ret = tmp ; } ret } } impl < 'r > :: core :: ops :: Add < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn add (self , other : & Internal) -> Internal { use :: core :: ops :: AddAssign ; let mut ret = self ; ret . add_assign (other) ; ret } } impl :: core :: ops :: Add for Internal { type Output = Internal ; # [inline] fn add (self , other : Internal) -> Self { self + & other } } impl < 'r > :: core :: ops :: AddAssign < & 'r Internal > for Internal { # [inline] fn add_assign (& mut self , other : & Internal) { self . add_nocarry (other) ; self . reduce () ; } } impl :: core :: ops :: AddAssign for Internal { # [inline] fn add_assign (& mut self , other : Internal) { self . add_assign (& other) ; } } impl < 'r > :: core :: ops :: Sub < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn sub (self , other : & Internal) -> Self { use :: core :: ops :: SubAssign ; let mut ret = self ; ret . sub_assign (other) ; ret } } impl :: core :: ops :: Sub for Internal { type Output = Internal ; # [inline] fn sub (self , other : Internal) -> Self { self - & other } } impl < 'r > :: core :: ops :: SubAssign < & 'r Internal > for Internal { # [inline] fn sub_assign (& mut self , other : & Internal) { if other . cmp_native (self) == :: core :: cmp :: Ordering :: Greater { self . add_nocarry (& MODULUS_LIMBS) ; } self . sub_noborrow (other) ; } } impl :: core :: ops :: SubAssign for Internal { # [inline] fn sub_assign (& mut self , other : Internal) { self . sub_assign (& other) ; } } impl < 'r > :: core :: ops :: Mul < & 'r Internal > for Internal { type Output = Internal ; # [inline] fn mul (self , other : & Internal) -> Self { use :: core :: ops :: MulAssign ; let mut ret = self ; ret . mul_assign (other) ; ret } } impl :: core :: ops :: Mul for Internal { type Output = Internal ; # [inline] fn mul (self , other : Internal) -> Self { self * & other } } impl < 'r > :: core :: ops :: MulAssign < & 'r Internal > for Internal { # [inline] fn mul_assign (& mut self , other : & Internal) { let carry = 0 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [0usize] , carry) ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [4usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [5usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , other . 0 [6usize] , carry) ; let r7 = carry ; let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (r1 , self . 0 [1usize] , other . 0 [0usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , other . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , other . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , other . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [1usize] , other . 0 [4usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [1usize] , other . 0 [5usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [1usize] , other . 0 [6usize] , carry) ; let r8 = carry ; let carry = 0 ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [2usize] , other . 0 [0usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [2usize] , other . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , other . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , other . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [2usize] , other . 0 [4usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [2usize] , other . 0 [5usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [2usize] , other . 0 [6usize] , carry) ; let r9 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [3usize] , other . 0 [0usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [3usize] , other . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [3usize] , other . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , other . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [3usize] , other . 0 [4usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [3usize] , other . 0 [5usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [3usize] , other . 0 [6usize] , carry) ; let r10 = carry ; let carry = 0 ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [4usize] , other . 0 [0usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [4usize] , other . 0 [1usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [4usize] , other . 0 [2usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [4usize] , other . 0 [3usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [4usize] , other . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [4usize] , other . 0 [5usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [4usize] , other . 0 [6usize] , carry) ; let r11 = carry ; let carry = 0 ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [5usize] , other . 0 [0usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [5usize] , other . 0 [1usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [5usize] , other . 0 [2usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [5usize] , other . 0 [3usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [5usize] , other . 0 [4usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [5usize] , other . 0 [5usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , self . 0 [5usize] , other . 0 [6usize] , carry) ; let r12 = carry ; let carry = 0 ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [6usize] , other . 0 [0usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [6usize] , other . 0 [1usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [6usize] , other . 0 [2usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [6usize] , other . 0 [3usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [6usize] , other . 0 [4usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , self . 0 [6usize] , other . 0 [5usize] , carry) ; let (r12 , carry) = :: ff :: derive :: mac (r12 , self . 0 [6usize] , other . 0 [6usize] , carry) ; let r13 = carry ; self . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r10 , r11 , r12 , r13) ; } } impl :: core :: ops :: MulAssign for Internal { # [inline] fn mul_assign (& mut self , other : Internal) { self . mul_assign (& other) ; } } impl :: ff :: PrimeField for Internal { type Repr = InternalRepr ; fn from_repr (r : InternalRepr) -> :: ff :: derive :: subtle :: CtOption < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 7usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; let borrow = r . 0 . iter () . zip (MODULUS_LIMBS . 0 . iter ()) . fold (0 , | borrow , (a , b) | { :: ff :: derive :: sbb (* a , * b , borrow) . 1 }) ; let is_some = :: ff :: derive :: subtle :: Choice :: from ((borrow as u8) & 1) ; :: ff :: derive :: subtle :: CtOption :: new (r * & R2 , is_some) } fn from_repr_vartime (r : InternalRepr) -> Option < Internal > { use :: ff :: derive :: byteorder :: ByteOrder ; let r = { let mut inner = [0u64 ; 7usize] ; :: ff :: derive :: byteorder :: LittleEndian :: read_u64_into (r . as_ref () , & mut inner [..]) ; Internal (inner) } ; if r . is_valid () { Some (r * R2) } else { None } } fn to_repr (& self) -> InternalRepr { use :: ff :: derive :: byteorder :: ByteOrder ; let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , self . 0 [5usize] , self . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; let mut repr = [0u8 ; 56usize] ; :: ff :: derive :: byteorder :: LittleEndian :: write_u64_into (& r . 0 , & mut repr [..]) ; InternalRepr (repr) } # [inline (always)] fn is_odd (& self) -> :: ff :: derive :: subtle :: Choice { let mut r = * self ; r . mont_reduce (self . 0 [0usize] , self . 0 [1usize] , self . 0 [2usize] , self . 0 [3usize] , self . 0 [4usize] , self . 0 [5usize] , self . 0 [6usize] , 0 , 0 , 0 , 0 , 0 , 0 , 0) ; :: ff :: derive :: subtle :: Choice :: from ((r . 0 [0] & 1) as u8) } const NUM_BITS : u32 = MODULUS_BITS ; const CAPACITY : u32 = Self :: NUM_BITS - 1 ; fn multiplicative_generator () -> Self { GENERATOR } const MULTIPLICATIVE_GENERATOR : Self = GENERATOR ; const S : u32 = S ; fn root_of_unity () -> Self { ROOT_OF_UNITY } } impl :: ff :: Field for Internal { # [doc = r" Computes a uniformly random element using rejection sampling."] fn random (mut rng : impl :: ff :: derive :: rand_core :: RngCore) -> Self { loop { let mut tmp = { let mut repr = [0u64 ; 7usize] ; for i in 0 .. 7usize { repr [i] = rng . next_u64 () ; } Internal (repr) } ; tmp . 0 . as_mut () [6usize] &= 0xffffffffffffffffu64 . checked_shr (REPR_SHAVE_BITS) . unwrap_or (0) ; if tmp . is_valid () { return tmp } } } # [inline] fn zero () -> Self { Internal ([0 ; 7usize]) } const ZERO : Self = Internal ([0 ; 7usize]) ; # [inline] fn one () -> Self { R } const ONE : Self = R ; # [inline] fn is_zero (& self) -> :: ff :: derive :: subtle :: Choice { use :: ff :: derive :: subtle :: ConstantTimeEq ; self . ct_eq (& Self :: zero ()) } # [inline] fn is_zero_vartime (& self) -> bool { self . 0 . iter () . all (| & e | e == 0) } # [inline] fn double (& self) -> Self { let mut ret = * self ; let mut last = 0 ; for i in & mut ret . 0 { let tmp = * i >> 63 ; * i <<= 1 ; * i |= last ; last = tmp ; } ret . reduce () ; ret } fn invert (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let inv = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 . square () ; let t3 = t2 * t1 ; let t4 = t3 . square () ; let t5 = t4 * t1 ; let t6 = t5 * t0 ; let t7 = t6 . square () ; let t8 = t7 . square () ; let t9 = t8 * t1 ; let t10 = t9 * t0 ; let t11 = t10 * t9 ; let t12 = t11 * t10 ; let t13 = t12 * t11 ; let t14 = t13 . square () ; let t15 = t14 * t13 ; let t16 = t15 . square () ; let t17 = t16 * t13 ; let t18 = t17 * t12 ; let t19 = t18 . square () ; let t20 = t19 . square () ; let t21 = t20 * t18 ; let t22 = t21 . square () ; let t23 = t22 . square () ; let t24 = t23 . square () ; let t25 = t24 * t20 ; let t26 = t25 . square () ; let t27 = t26 * t21 ; let t28 = t27 . square () ; let t29 = t28 * t27 ; let t30 = t29 * t25 ; let t31 = t30 . square () ; let t32 = t31 . square () ; let t33 = t32 * t27 ; let t34 = t33 . square () ; let t35 = t34 * t30 ; let t36 = t35 . square () ; let t37 = t36 . square () ; let t38 = t37 . square () ; let t39 = t38 * t35 ; let t40 = t39 * t37 ; let t41 = t40 . square () ; let t42 = t41 * t40 ; let t43 = t42 . square () ; let t44 = t42 . square () ; let t45 = t43 . square () ; let t46 = t45 * t40 ; let t47 = t46 * t39 ; let t48 = t47 . square () ; let t49 = t48 . square () ; let t50 = t49 * t47 ; let t51 = t50 . square () ; let t52 = t50 . square () ; let t53 = t51 . square () ; let t54 = t53 . square () ; let t55 = t54 * t47 ; let t56 = t55 * t40 ; let t57 = t56 . square () ; let t58 = t57 * t47 ; let t59 = t58 * t56 ; let t60 = t59 . square () ; let t61 = t60 * t59 ; let t62 = t61 . square () ; let t63 = t62 * t61 ; let t64 = t63 . square () ; let t65 = t63 . square () ; let t66 = t64 * t60 ; let t67 = t66 . square () ; let t68 = t67 . square () ; let t69 = t68 . square () ; let t70 = t69 * t61 ; let t71 = t70 * t58 ; let t72 = t71 . square () ; let t73 = t72 * t59 ; let t74 = t73 . square () ; let t75 = t74 * t73 ; let t76 = t75 * t71 ; let t77 = t76 * t73 ; let t78 = t77 . square () ; let t79 = t78 * t76 ; let t80 = t79 . square () ; let t81 = t80 * t79 ; let t82 = t81 * t77 ; let t83 = t82 * t79 ; let t84 = t83 . square () ; let t85 = t84 * t83 ; let t86 = t85 * t82 ; let t87 = t86 . square () ; let t88 = t87 . square () ; let t89 = t88 * t87 ; let t90 = t88 * t87 ; let t91 = t89 . square () ; let t92 = t91 . square () ; let t93 = t92 * t87 ; let t94 = t93 * t83 ; let t95 = t94 . square () ; let t96 = t95 . square () ; let t97 = t96 . square () ; let t98 = t97 . square () ; let t99 = t98 . square () ; let t100 = t99 . square () ; let t101 = t100 . square () ; let t102 = t101 . square () ; let t103 = t102 . square () ; let t104 = t103 . square () ; let t105 = t104 . square () ; let t106 = t105 . square () ; let t107 = t106 . square () ; let t108 = t107 . square () ; let t109 = t108 . square () ; let t110 = t109 . square () ; let t111 = t110 . square () ; let t112 = t111 . square () ; let t113 = t112 . square () ; let t114 = t113 . square () ; let t115 = t114 . square () ; let t116 = t115 . square () ; let t117 = t116 . square () ; let t118 = t117 . square () ; let t119 = t118 . square () ; let t120 = t119 . square () ; let t121 = t120 . square () ; let t122 = t121 . square () ; let t123 = t122 . square () ; let t124 = t123 . square () ; let t125 = t124 . square () ; let t126 = t125 . square () ; let t127 = t126 . square () ; let t128 = t127 . square () ; let t129 = t128 . square () ; let t130 = t129 * t86 ; let t131 = t130 * t33 ; let t132 = t131 * t35 ; let t133 = t132 * t131 ; let t134 = t133 . square () ; let t135 = t134 * t133 ; let t136 = t135 . square () ; let t137 = t135 . square () ; let t138 = t136 * t132 ; let t139 = t138 * t133 ; let t140 = t139 . square () ; let t141 = t140 . square () ; let t142 = t141 . square () ; let t143 = t142 . square () ; let t144 = t143 * t139 ; let t145 = t144 * t138 ; let t146 = t145 * t139 ; let t147 = t146 . square () ; let t148 = t147 * t146 ; let t149 = t148 . square () ; let t150 = t149 * t146 ; let t151 = t150 . square () ; let t152 = t151 . square () ; let t153 = t151 . square () ; let t154 = t152 * t145 ; let t155 = t154 . square () ; let t156 = t155 . square () ; let t157 = t156 . square () ; let t158 = t157 . square () ; let t159 = t158 . square () ; let t160 = t159 . square () ; let t161 = t160 . square () ; let t162 = t161 . square () ; let t163 = t162 . square () ; let t164 = t163 . square () ; let t165 = t164 . square () ; let t166 = t165 . square () ; let t167 = t166 . square () ; let t168 = t167 . square () ; let t169 = t168 . square () ; let t170 = t169 . square () ; let t171 = t170 . square () ; let t172 = t171 . square () ; let t173 = t172 . square () ; let t174 = t173 . square () ; let t175 = t174 . square () ; let t176 = t175 . square () ; let t177 = t176 . square () ; let t178 = t177 . square () ; let t179 = t178 . square () ; let t180 = t179 . square () ; let t181 = t180 . square () ; let t182 = t181 . square () ; let t183 = t182 . square () ; let t184 = t183 . square () ; let t185 = t184 . square () ; let t186 = t185 . square () ; let t187 = t186 . square () ; let t188 = t187 . square () ; let t189 = t188 . square () ; let t190 = t189 . square () ; let t191 = t190 . square () ; let t192 = t191 . square () ; let t193 = t192 . square () ; let t194 = t193 . square () ; let t195 = t194 . square () ; let t196 = t195 . square () ; let t197 = t196 . square () ; let t198 = t197 . square () ; let t199 = t198 . square () ; let t200 = t199 . square () ; let t201 = t200 . square () ; let t202 = t201 . square () ; let t203 = t202 . square () ; let t204 = t203 . square () ; let t205 = t204 . square () ; let t206 = t205 . square () ; let t207 = t206 . square () ; let t208 = t207 . square () ; let t209 = t208 . square () ; let t210 = t209 . square () ; let t211 = t210 . square () ; let t212 = t211 . square () ; let t213 = t212 . square () ; let t214 = t213 . square () ; let t215 = t214 . square () ; let t216 = t215 . square () ; let t217 = t216 . square () ; let t218 = t217 . square () ; let t219 = t218 . square () ; let t220 = t219 . square () ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 . square () ; let t228 = t227 . square () ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 . square () ; let t234 = t233 . square () ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 . square () ; let t240 = t239 . square () ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 . square () ; let t245 = t244 . square () ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 * t146 ; let t249 = t248 * t13 ; let t250 = t249 . square () ; let t251 = t250 . square () ; let t252 = t251 * t18 ; let t253 = t252 . square () ; let t254 = t253 . square () ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 . square () ; let t258 = t257 . square () ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 . square () ; let t262 = t261 . square () ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 . square () ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 . square () ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 . square () ; let t272 = t271 . square () ; let t273 = t272 . square () ; let t274 = t273 . square () ; let t275 = t274 . square () ; let t276 = t275 . square () ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 . square () ; let t281 = t280 . square () ; let t282 = t281 . square () ; let t283 = t282 . square () ; let t284 = t283 . square () ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 . square () ; let t289 = t288 . square () ; let t290 = t289 . square () ; let t291 = t290 . square () ; let t292 = t291 . square () ; let t293 = t292 . square () ; let t294 = t293 . square () ; let t295 = t294 . square () ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 . square () ; let t299 = t298 . square () ; let t300 = t299 . square () ; let t301 = t300 . square () ; let t302 = t301 . square () ; let t303 = t302 . square () ; let t304 = t303 . square () ; let t305 = t304 . square () ; let t306 = t305 . square () ; let t307 = t306 . square () ; let t308 = t307 . square () ; let t309 = t308 . square () ; let t310 = t309 . square () ; let t311 = t310 . square () ; let t312 = t311 . square () ; let t313 = t312 . square () ; let t314 = t313 . square () ; let t315 = t314 . square () ; let t316 = t315 . square () ; let t317 = t316 . square () ; let t318 = t317 . square () ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 . square () ; let t322 = t321 . square () ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 . square () ; let t339 = t338 . square () ; let t340 = t339 . square () ; let t341 = t340 . square () ; let t342 = t341 . square () ; let t343 = t342 . square () ; let t344 = t343 . square () ; let t345 = t344 . square () ; let t346 = t345 . square () ; let t347 = t346 . square () ; let t348 = t347 . square () ; let t349 = t348 . square () ; let t350 = t349 . square () ; let t351 = t350 . square () ; let t352 = t351 . square () ; let t353 = t352 . square () ; let t354 = t353 . square () ; let t355 = t354 . square () ; let t356 = t355 . square () ; let t357 = t356 . square () ; let t358 = t357 . square () ; let t359 = t358 . square () ; let t360 = t359 . square () ; let t361 = t360 . square () ; let t362 = t361 . square () ; let t363 = t362 . square () ; let t364 = t363 . square () ; let t365 = t364 . square () ; let t366 = t365 . square () ; let t367 = t366 . square () ; let t368 = t367 . square () ; let t369 = t368 . square () ; let t370 = t369 . square () ; let t371 = t370 . square () ; let t372 = t371 . square () ; let t373 = t372 . square () ; let t374 = t373 . square () ; let t375 = t374 . square () ; let t376 = t375 . square () ; let t377 = t376 . square () ; let t378 = t377 . square () ; let t379 = t378 . square () ; let t380 = t379 . square () ; let t381 = t380 . square () ; let t382 = t381 . square () ; let t383 = t382 . square () ; let t384 = t383 . square () ; let t385 = t384 . square () ; let t386 = t385 . square () ; let t387 = t386 . square () ; let t388 = t387 . square () ; let t389 = t388 . square () ; let t390 = t389 . square () ; let t391 = t390 . square () ; let t392 = t391 . square () ; let t393 = t392 . square () ; let t394 = t393 . square () ; let t395 = t394 . square () ; let t396 = t395 . square () ; let t397 = t396 . square () ; let t398 = t397 . square () ; let t399 = t398 . square () ; let t400 = t399 . square () ; let t401 = t400 . square () ; let t402 = t401 . square () ; let t403 = t402 . square () ; let t404 = t403 . square () ; let t405 = t404 . square () ; let t406 = t405 . square () ; let t407 = t406 . square () ; let t408 = t407 . square () ; let t409 = t408 . square () ; let t410 = t409 . square () ; let t411 = t410 . square () ; let t412 = t411 . square () ; let t413 = t412 . square () ; let t414 = t413 . square () ; let t415 = t414 . square () ; let t416 = t415 . square () ; let t417 = t416 . square () ; let t418 = t417 . square () ; let t419 = t418 . square () ; let t420 = t419 . square () ; let t421 = t420 . square () ; let t422 = t421 . square () ; let t423 = t422 . square () ; let t424 = t423 . square () ; let t425 = t424 . square () ; let t426 = t425 . square () ; let t427 = t426 . square () ; let t428 = t427 . square () ; let t429 = t428 . square () ; let t430 = t429 . square () ; let t431 = t430 . square () ; let t432 = t431 . square () ; let t433 = t432 . square () ; let t434 = t433 . square () ; let t435 = t434 . square () ; let t436 = t435 . square () ; let t437 = t436 . square () ; let t438 = t437 . square () ; let t439 = t438 . square () ; let t440 = t439 . square () ; let t441 = t440 . square () ; let t442 = t441 . square () ; let t443 = t442 . square () ; let t444 = t443 . square () ; let t445 = t444 . square () ; let t446 = t445 . square () ; let t447 = t446 . square () ; let t448 = t447 . square () ; let t449 = t448 . square () ; let t450 = t449 . square () ; let t451 = t450 . square () ; let t452 = t451 * t249 ; t452 } ; :: ff :: derive :: subtle :: CtOption :: new (inv , ! self . ct_eq (& Internal :: zero ())) } # [inline] fn square (& self) -> Self { let carry = 0 ; let (r1 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [4usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [5usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [6usize] , carry) ; let r7 = carry ; let carry = 0 ; let (r3 , carry) = :: ff :: derive :: mac (r3 , self . 0 [1usize] , self . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [1usize] , self . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [1usize] , self . 0 [4usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [1usize] , self . 0 [5usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [1usize] , self . 0 [6usize] , carry) ; let r8 = carry ; let carry = 0 ; let (r5 , carry) = :: ff :: derive :: mac (r5 , self . 0 [2usize] , self . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [2usize] , self . 0 [4usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [2usize] , self . 0 [5usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [2usize] , self . 0 [6usize] , carry) ; let r9 = carry ; let carry = 0 ; let (r7 , carry) = :: ff :: derive :: mac (r7 , self . 0 [3usize] , self . 0 [4usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [3usize] , self . 0 [5usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [3usize] , self . 0 [6usize] , carry) ; let r10 = carry ; let carry = 0 ; let (r9 , carry) = :: ff :: derive :: mac (r9 , self . 0 [4usize] , self . 0 [5usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [4usize] , self . 0 [6usize] , carry) ; let r11 = carry ; let carry = 0 ; let (r11 , carry) = :: ff :: derive :: mac (r11 , self . 0 [5usize] , self . 0 [6usize] , carry) ; let r12 = carry ; let r13 = r12 >> 63 ; let r12 = (r12 << 1) | (r11 >> 63) ; let r11 = (r11 << 1) | (r10 >> 63) ; let r10 = (r10 << 1) | (r9 >> 63) ; let r9 = (r9 << 1) | (r8 >> 63) ; let r8 = (r8 << 1) | (r7 >> 63) ; let r7 = (r7 << 1) | (r6 >> 63) ; let r6 = (r6 << 1) | (r5 >> 63) ; let r5 = (r5 << 1) | (r4 >> 63) ; let r4 = (r4 << 1) | (r3 >> 63) ; let r3 = (r3 << 1) | (r2 >> 63) ; let r2 = (r2 << 1) | (r1 >> 63) ; let r1 = r1 << 1 ; let (r0 , carry) = :: ff :: derive :: mac (0 , self . 0 [0usize] , self . 0 [0usize] , 0) ; let (r1 , carry) = :: ff :: derive :: adc (r1 , 0 , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , self . 0 [1usize] , self . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: adc (r3 , 0 , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , self . 0 [2usize] , self . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: adc (r5 , 0 , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , self . 0 [3usize] , self . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: adc (r7 , 0 , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , self . 0 [4usize] , self . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: adc (r9 , 0 , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , self . 0 [5usize] , self . 0 [5usize] , carry) ; let (r11 , carry) = :: ff :: derive :: adc (r11 , 0 , carry) ; let (r12 , carry) = :: ff :: derive :: mac (r12 , self . 0 [6usize] , self . 0 [6usize] , carry) ; let (r13 , carry) = :: ff :: derive :: adc (r13 , 0 , carry) ; let mut ret = * self ; ret . mont_reduce (r0 , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r10 , r11 , r12 , r13) ; ret } fn sqrt (& self) -> :: ff :: derive :: subtle :: CtOption < Self > { use :: ff :: derive :: subtle :: ConstantTimeEq ; let sqrt = { let t0 = self ; let t1 = t0 . square () ; let t2 = t1 * t0 ; let t3 = t2 . square () ; let t4 = t2 . square () ; let t5 = t3 * t2 ; let t6 = t5 * t3 ; let t7 = t6 . square () ; let t8 = t7 . square () ; let t9 = t8 . square () ; let t10 = t9 * t6 ; let t11 = t10 * t5 ; let t12 = t11 . square () ; let t13 = t12 * t11 ; let t14 = t13 * t6 ; let t15 = t14 * t11 ; let t16 = t15 . square () ; let t17 = t16 . square () ; let t18 = t17 * t16 ; let t19 = t18 . square () ; let t20 = t19 * t16 ; let t21 = t20 * t15 ; let t22 = t21 * t16 ; let t23 = t22 . square () ; let t24 = t23 . square () ; let t25 = t24 * t23 ; let t26 = t25 . square () ; let t27 = t26 * t23 ; let t28 = t26 * t23 ; let t29 = t27 . square () ; let t30 = t29 . square () ; let t31 = t30 * t23 ; let t32 = t31 * t21 ; let t33 = t32 . square () ; let t34 = t33 . square () ; let t35 = t34 . square () ; let t36 = t35 * t34 ; let t37 = t36 . square () ; let t38 = t36 . square () ; let t39 = t37 . square () ; let t40 = t37 . square () ; let t41 = t37 . square () ; let t42 = t39 * t34 ; let t43 = t42 . square () ; let t44 = t43 * t39 ; let t45 = t44 . square () ; let t46 = t45 * t42 ; let t47 = t46 . square () ; let t48 = t47 * t44 ; let t49 = t48 * t46 ; let t50 = t49 . square () ; let t51 = t50 * t49 ; let t52 = t51 * t48 ; let t53 = t52 . square () ; let t54 = t53 * t52 ; let t55 = t54 . square () ; let t56 = t54 . square () ; let t57 = t55 * t49 ; let t58 = t57 * t52 ; let t59 = t58 . square () ; let t60 = t59 * t58 ; let t61 = t60 . square () ; let t62 = t61 . square () ; let t63 = t62 * t58 ; let t64 = t63 . square () ; let t65 = t64 . square () ; let t66 = t65 * t60 ; let t67 = t66 * t57 ; let t68 = t67 * t58 ; let t69 = t68 * t67 ; let t70 = t69 * t68 ; let t71 = t70 . square () ; let t72 = t71 . square () ; let t73 = t72 * t70 ; let t74 = t73 * t69 ; let t75 = t74 * t70 ; let t76 = t75 . square () ; let t77 = t76 . square () ; let t78 = t77 * t75 ; let t79 = t78 * t74 ; let t80 = t79 . square () ; let t81 = t80 . square () ; let t82 = t81 * t79 ; let t83 = t82 . square () ; let t84 = t83 * t79 ; let t85 = t84 . square () ; let t86 = t85 . square () ; let t87 = t85 . square () ; let t88 = t86 * t75 ; let t89 = t88 * t79 ; let t90 = t89 * t88 ; let t91 = t90 * t89 ; let t92 = t91 . square () ; let t93 = t92 * t91 ; let t94 = t93 * t90 ; let t95 = t94 . square () ; let t96 = t95 * t91 ; let t97 = t96 . square () ; let t98 = t97 . square () ; let t99 = t98 . square () ; let t100 = t99 . square () ; let t101 = t100 . square () ; let t102 = t101 . square () ; let t103 = t102 . square () ; let t104 = t103 . square () ; let t105 = t104 . square () ; let t106 = t105 . square () ; let t107 = t106 . square () ; let t108 = t107 . square () ; let t109 = t108 . square () ; let t110 = t109 . square () ; let t111 = t110 . square () ; let t112 = t111 . square () ; let t113 = t112 . square () ; let t114 = t113 . square () ; let t115 = t114 . square () ; let t116 = t115 . square () ; let t117 = t116 . square () ; let t118 = t117 . square () ; let t119 = t118 . square () ; let t120 = t119 . square () ; let t121 = t120 . square () ; let t122 = t121 . square () ; let t123 = t122 . square () ; let t124 = t123 . square () ; let t125 = t124 . square () ; let t126 = t125 . square () ; let t127 = t126 . square () ; let t128 = t127 . square () ; let t129 = t128 . square () ; let t130 = t129 . square () ; let t131 = t130 . square () ; let t132 = t131 . square () ; let t133 = t132 . square () ; let t134 = t133 * t94 ; let t135 = t134 * t22 ; let t136 = t135 . square () ; let t137 = t136 * t135 ; let t138 = t137 . square () ; let t139 = t137 . square () ; let t140 = t138 . square () ; let t141 = t140 * t135 ; let t142 = t141 * t32 ; let t143 = t142 . square () ; let t144 = t143 * t142 ; let t145 = t144 * t135 ; let t146 = t145 . square () ; let t147 = t146 * t142 ; let t148 = t147 * t145 ; let t149 = t148 . square () ; let t150 = t149 * t148 ; let t151 = t150 . square () ; let t152 = t151 * t148 ; let t153 = t152 * t147 ; let t154 = t153 . square () ; let t155 = t154 . square () ; let t156 = t155 . square () ; let t157 = t156 . square () ; let t158 = t157 . square () ; let t159 = t158 . square () ; let t160 = t159 . square () ; let t161 = t160 . square () ; let t162 = t161 . square () ; let t163 = t162 . square () ; let t164 = t163 . square () ; let t165 = t164 . square () ; let t166 = t165 . square () ; let t167 = t166 . square () ; let t168 = t167 . square () ; let t169 = t168 . square () ; let t170 = t169 . square () ; let t171 = t170 . square () ; let t172 = t171 . square () ; let t173 = t172 . square () ; let t174 = t173 . square () ; let t175 = t174 . square () ; let t176 = t175 . square () ; let t177 = t176 . square () ; let t178 = t177 . square () ; let t179 = t178 . square () ; let t180 = t179 . square () ; let t181 = t180 . square () ; let t182 = t181 . square () ; let t183 = t182 . square () ; let t184 = t183 . square () ; let t185 = t184 . square () ; let t186 = t185 . square () ; let t187 = t186 . square () ; let t188 = t187 . square () ; let t189 = t188 . square () ; let t190 = t189 . square () ; let t191 = t190 . square () ; let t192 = t191 . square () ; let t193 = t192 . square () ; let t194 = t193 . square () ; let t195 = t194 . square () ; let t196 = t195 . square () ; let t197 = t196 . square () ; let t198 = t197 . square () ; let t199 = t198 . square () ; let t200 = t199 . square () ; let t201 = t200 . square () ; let t202 = t201 . square () ; let t203 = t202 . square () ; let t204 = t203 . square () ; let t205 = t204 . square () ; let t206 = t205 . square () ; let t207 = t206 . square () ; let t208 = t207 . square () ; let t209 = t208 . square () ; let t210 = t209 . square () ; let t211 = t210 . square () ; let t212 = t211 . square () ; let t213 = t212 . square () ; let t214 = t213 . square () ; let t215 = t214 . square () ; let t216 = t215 . square () ; let t217 = t216 . square () ; let t218 = t217 . square () ; let t219 = t218 . square () ; let t220 = t219 . square () ; let t221 = t220 . square () ; let t222 = t221 . square () ; let t223 = t222 . square () ; let t224 = t223 . square () ; let t225 = t224 . square () ; let t226 = t225 . square () ; let t227 = t226 . square () ; let t228 = t227 . square () ; let t229 = t228 . square () ; let t230 = t229 . square () ; let t231 = t230 . square () ; let t232 = t231 . square () ; let t233 = t232 . square () ; let t234 = t233 . square () ; let t235 = t234 . square () ; let t236 = t235 . square () ; let t237 = t236 . square () ; let t238 = t237 . square () ; let t239 = t238 . square () ; let t240 = t239 . square () ; let t241 = t240 . square () ; let t242 = t241 . square () ; let t243 = t242 . square () ; let t244 = t243 . square () ; let t245 = t244 . square () ; let t246 = t245 . square () ; let t247 = t246 . square () ; let t248 = t247 * t148 ; let t249 = t248 * t14 ; let t250 = t249 . square () ; let t251 = t250 . square () ; let t252 = t251 * t15 ; let t253 = t252 . square () ; let t254 = t253 . square () ; let t255 = t254 . square () ; let t256 = t255 . square () ; let t257 = t256 . square () ; let t258 = t257 . square () ; let t259 = t258 . square () ; let t260 = t259 . square () ; let t261 = t260 . square () ; let t262 = t261 . square () ; let t263 = t262 . square () ; let t264 = t263 . square () ; let t265 = t264 . square () ; let t266 = t265 . square () ; let t267 = t266 . square () ; let t268 = t267 . square () ; let t269 = t268 . square () ; let t270 = t269 . square () ; let t271 = t270 . square () ; let t272 = t271 . square () ; let t273 = t272 . square () ; let t274 = t273 . square () ; let t275 = t274 . square () ; let t276 = t275 . square () ; let t277 = t276 . square () ; let t278 = t277 . square () ; let t279 = t278 . square () ; let t280 = t279 . square () ; let t281 = t280 . square () ; let t282 = t281 . square () ; let t283 = t282 . square () ; let t284 = t283 . square () ; let t285 = t284 . square () ; let t286 = t285 . square () ; let t287 = t286 . square () ; let t288 = t287 . square () ; let t289 = t288 . square () ; let t290 = t289 . square () ; let t291 = t290 . square () ; let t292 = t291 . square () ; let t293 = t292 . square () ; let t294 = t293 . square () ; let t295 = t294 . square () ; let t296 = t295 . square () ; let t297 = t296 . square () ; let t298 = t297 . square () ; let t299 = t298 . square () ; let t300 = t299 . square () ; let t301 = t300 . square () ; let t302 = t301 . square () ; let t303 = t302 . square () ; let t304 = t303 . square () ; let t305 = t304 . square () ; let t306 = t305 . square () ; let t307 = t306 . square () ; let t308 = t307 . square () ; let t309 = t308 . square () ; let t310 = t309 . square () ; let t311 = t310 . square () ; let t312 = t311 . square () ; let t313 = t312 . square () ; let t314 = t313 . square () ; let t315 = t314 . square () ; let t316 = t315 . square () ; let t317 = t316 . square () ; let t318 = t317 . square () ; let t319 = t318 . square () ; let t320 = t319 . square () ; let t321 = t320 . square () ; let t322 = t321 . square () ; let t323 = t322 . square () ; let t324 = t323 . square () ; let t325 = t324 . square () ; let t326 = t325 . square () ; let t327 = t326 . square () ; let t328 = t327 . square () ; let t329 = t328 . square () ; let t330 = t329 . square () ; let t331 = t330 . square () ; let t332 = t331 . square () ; let t333 = t332 . square () ; let t334 = t333 . square () ; let t335 = t334 . square () ; let t336 = t335 . square () ; let t337 = t336 . square () ; let t338 = t337 . square () ; let t339 = t338 . square () ; let t340 = t339 . square () ; let t341 = t340 . square () ; let t342 = t341 . square () ; let t343 = t342 . square () ; let t344 = t343 . square () ; let t345 = t344 . square () ; let t346 = t345 . square () ; let t347 = t346 . square () ; let t348 = t347 . square () ; let t349 = t348 . square () ; let t350 = t349 . square () ; let t351 = t350 . square () ; let t352 = t351 . square () ; let t353 = t352 . square () ; let t354 = t353 . square () ; let t355 = t354 . square () ; let t356 = t355 . square () ; let t357 = t356 . square () ; let t358 = t357 . square () ; let t359 = t358 . square () ; let t360 = t359 . square () ; let t361 = t360 . square () ; let t362 = t361 . square () ; let t363 = t362 . square () ; let t364 = t363 . square () ; let t365 = t364 . square () ; let t366 = t365 . square () ; let t367 = t366 . square () ; let t368 = t367 . square () ; let t369 = t368 . square () ; let t370 = t369 . square () ; let t371 = t370 . square () ; let t372 = t371 . square () ; let t373 = t372 . square () ; let t374 = t373 . square () ; let t375 = t374 . square () ; let t376 = t375 . square () ; let t377 = t376 . square () ; let t378 = t377 . square () ; let t379 = t378 . square () ; let t380 = t379 . square () ; let t381 = t380 . square () ; let t382 = t381 . square () ; let t383 = t382 . square () ; let t384 = t383 . square () ; let t385 = t384 . square () ; let t386 = t385 . square () ; let t387 = t386 . square () ; let t388 = t387 . square () ; let t389 = t388 . square () ; let t390 = t389 . square () ; let t391 = t390 . square () ; let t392 = t391 . square () ; let t393 = t392 . square () ; let t394 = t393 . square () ; let t395 = t394 . square () ; let t396 = t395 . square () ; let t397 = t396 . square () ; let t398 = t397 . square () ; let t399 = t398 . square () ; let t400 = t399 . square () ; let t401 = t400 . square () ; let t402 = t401 . square () ; let t403 = t402 . square () ; let t404 = t403 . square () ; let t405 = t404 . square () ; let t406 = t405 . square () ; let t407 = t406 . square () ; let t408 = t407 . square () ; let t409 = t408 . square () ; let t410 = t409 . square () ; let t411 = t410 . square () ; let t412 = t411 . square () ; let t413 = t412 . square () ; let t414 = t413 . square () ; let t415 = t414 . square () ; let t416 = t415 . square () ; let t417 = t416 . square () ; let t418 = t417 . square () ; let t419 = t418 . square () ; let t420 = t419 . square () ; let t421 = t420 . square () ; let t422 = t421 . square () ; let t423 = t422 . square () ; let t424 = t423 . square () ; let t425 = t424 . square () ; let t426 = t425 . square () ; let t427 = t426 . square () ; let t428 = t427 . square () ; let t429 = t428 . square () ; let t430 = t429 . square () ; let t431 = t430 . square () ; let t432 = t431 . square () ; let t433 = t432 . square () ; let t434 = t433 . square () ; let t435 = t434 . square () ; let t436 = t435 . square () ; let t437 = t436 . square () ; let t438 = t437 . square () ; let t439 = t438 . square () ; let t440 = t439 . square () ; let t441 = t440 . square () ; let t442 = t441 . square () ; let t443 = t442 . square () ; let t444 = t443 . square () ; let t445 = t444 . square () ; let t446 = t445 . square () ; let t447 = t446 . square () ; let t448 = t447 . square () ; let t449 = t448 . square () ; let t450 = t449 . square () ; let t451 = t450 * t249 ; t451 } ; :: ff :: derive :: subtle :: CtOption :: new (sqrt , (sqrt * & sqrt) . ct_eq (self) ,) } } impl Internal { # [doc = r" Compares two elements in native representation. This is only used"] # [doc = r" internally."] # [inline (always)] fn cmp_native (& self , other : & Internal) -> :: core :: cmp :: Ordering { for (a , b) in self . 0 . iter () . rev () . zip (other . 0 . iter () . rev ()) { if a < b { return :: core :: cmp :: Ordering :: Less } else if a > b { return :: core :: cmp :: Ordering :: Greater } } :: core :: cmp :: Ordering :: Equal } # [doc = r" Determines if the element is really in the field. This is only used"] # [doc = r" internally."] # [inline (always)] fn is_valid (& self) -> bool { self . cmp_native (& MODULUS_LIMBS) == :: core :: cmp :: Ordering :: Less } # [inline (always)] fn add_nocarry (& mut self , other : & Internal) { let mut carry = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_carry) = :: ff :: derive :: adc (* a , * b , carry) ; * a = new_a ; carry = new_carry ; } } # [inline (always)] fn sub_noborrow (& mut self , other : & Internal) { let mut borrow = 0 ; for (a , b) in self . 0 . iter_mut () . zip (other . 0 . iter ()) { let (new_a , new_borrow) = :: ff :: derive :: sbb (* a , * b , borrow) ; * a = new_a ; borrow = new_borrow ; } } # [doc = r" Subtracts the modulus from this element if this element is not in the"] # [doc = r" field. Only used interally."] # [inline (always)] fn reduce (& mut self) { if ! self . is_valid () { self . sub_noborrow (& MODULUS_LIMBS) ; } } # [allow (clippy :: too_many_arguments)] # [inline (always)] fn mont_reduce (& mut self , r0 : u64 , mut r1 : u64 , mut r2 : u64 , mut r3 : u64 , mut r4 : u64 , mut r5 : u64 , mut r6 : u64 , mut r7 : u64 , mut r8 : u64 , mut r9 : u64 , mut r10 : u64 , mut r11 : u64 , mut r12 : u64 , mut r13 : u64) { let k = r0 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r0 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r1 , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r7 , carry2) = :: ff :: derive :: adc (r7 , 0 , carry) ; let k = r1 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r1 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r2 , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r8 , carry2) = :: ff :: derive :: adc (r8 , carry2 , carry) ; let k = r2 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r2 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r3 , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r9 , carry2) = :: ff :: derive :: adc (r9 , carry2 , carry) ; let k = r3 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r3 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r4 , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r10 , carry2) = :: ff :: derive :: adc (r10 , carry2 , carry) ; let k = r4 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r4 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r5 , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r11 , carry2) = :: ff :: derive :: adc (r11 , carry2 , carry) ; let k = r5 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r5 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r6 , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r12 , carry2) = :: ff :: derive :: adc (r12 , carry2 , carry) ; let k = r6 . wrapping_mul (INV) ; let (_ , carry) = :: ff :: derive :: mac (r6 , k , MODULUS_LIMBS . 0 [0] , 0) ; let (r7 , carry) = :: ff :: derive :: mac (r7 , k , MODULUS_LIMBS . 0 [1usize] , carry) ; let (r8 , carry) = :: ff :: derive :: mac (r8 , k , MODULUS_LIMBS . 0 [2usize] , carry) ; let (r9 , carry) = :: ff :: derive :: mac (r9 , k , MODULUS_LIMBS . 0 [3usize] , carry) ; let (r10 , carry) = :: ff :: derive :: mac (r10 , k , MODULUS_LIMBS . 0 [4usize] , carry) ; let (r11 , carry) = :: ff :: derive :: mac (r11 , k , MODULUS_LIMBS . 0 [5usize] , carry) ; let (r12 , carry) = :: ff :: derive :: mac (r12 , k , MODULUS_LIMBS . 0 [6usize] , carry) ; let (r13 , carry2) = :: ff :: derive :: adc (r13 , carry2 , carry) ; self . 0 [0usize] = r7 ; self . 0 [1usize] = r8 ; self . 0 [2usize] = r9 ; self . 0 [3usize] = r10 ; self . 0 [4usize] = r11 ; self . 0 [5usize] = r12 ; self . 0 [6usize] = r13 ; self . reduce () ; } }#[cfg(test)] pub(super) const MODULUS_STRING: &str = "2582249878086908589655919172003011874329705792829223512830659356540647622016841194629645353280137831435903171972747492783";pub(super) const MODULUS_BYTES: &[u8] = &[175, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255];#[cfg(test)] pub(super) const GENERATOR_STRING: &str = "5";